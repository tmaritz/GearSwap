--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/
--
--	Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
--
--	Editing this file will cause you to be unable to use Github Desktop to update!
--
--	Any changes you wish to make in this file you should be able to make by overloading. That is Re-Defining the same variables or functions in another file, by copying and
--	pasting them to a file that is loaded after the original file, all of my library files, and then job files are loaded first.
--	The last files to load are the ones unique to you. User-Globals, Charactername-Globals, Charactername_Job_Gear, in that order, so these changes will take precedence.
--
--	You may wish to "hook" into existing functions, to add functionality without losing access to updates or fixes I make, for example, instead of copying and editing
--	status_change(), you can instead use the function user_status_change() in the same manner, which is called by status_change() if it exists, most of the important
--  gearswap functions work like this in my files, and if it's unique to a specific job, user_job_status_change() would be appropriate instead.
--
--  Variables and tables can be easily redefined just by defining them in one of the later loaded files: autofood = 'Miso Ramen' for example.
--  States can be redefined as well: state.HybridMode:options('Normal','PDT') though most of these are already redefined in the gear files for editing there.
--	Commands can be added easily with: user_self_command(commandArgs, eventArgs) or user_job_self_command(commandArgs, eventArgs)
--
--	If you're not sure where is appropriate to copy and paste variables, tables and functions to make changes or add them:
--		User-Globals.lua - 			This file loads with all characters, all jobs, so it's ideal for settings and rules you want to be the same no matter what.
--		Charactername-Globals.lua -	This file loads with one character, all jobs, so it's ideal for gear settings that are usable on all jobs, but unique to this character.
--		Charactername_Job_Gear.lua-	This file loads only on one character, one job, so it's ideal for things that are specific only to that job and character.
--
--
--	If you still need help, feel free to contact me on discord or ask in my chat for help: https://discord.gg/ug6xtvQ
--  !Please do NOT message me in game about anything third party related, though you're welcome to message me there and ask me to talk on another medium.
--
--  Please do not edit this file!							Please do not edit this file!							Please do not edit this file!
-- __________.__                                ________                          __               .__.__  __      __  .__    .__           _____.__.__
-- \______   |  |   ____ _____    ______ ____   \______ \   ____     ____   _____/  |_    ____   __| _|___/  |_  _/  |_|  |__ |__| ______ _/ ____|__|  |   ____
--  |     ___|  | _/ __ \\__  \  /  ____/ __ \   |    |  \ /  _ \   /    \ /  _ \   __\ _/ __ \ / __ ||  \   __\ \   __|  |  \|  |/  ___/ \   __\|  |  | _/ __ \
--  |    |   |  |_\  ___/ / __ \_\___ \\  ___/   |    `   (  <_> ) |   |  (  <_> |  |   \  ___// /_/ ||  ||  |    |  | |   Y  |  |\___ \   |  |  |  |  |_\  ___/
--  |____|   |____/\___  (____  /____  >\___  > /_______  /\____/  |___|  /\____/|__|    \___  \____ ||__||__|    |__| |___|  |__/____  >  |__|  |__|____/\___  > /\
--                     \/     \/     \/     \/          \/              \/                   \/     \/                      \/        \/                      \/  \/
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
-- General utility functions that can be used by any job files.
-- Outside the scope of what the main include file deals with.
-------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------
-- Buff utility functions.
-------------------------------------------------------------------------------------------------------------------

local cancel_spells_to_check = S{'Sneak','Stoneskin','Spectral Jig','Trance','Monomi: Ichi','Utsusemi: Ichi','Utsusemi: Ni','Diamondhide','Magic Barrier','Valiance'}
local cancel_types_to_check = S{'Waltz', 'Samba'}

-- Function to cancel buffs if they'd conflict with using the spell you're attempting.
-- Requirement: Must have Cancel addon installed and loaded for this to work.
function cancel_conflicting_buffs(spell, spellMap, eventArgs)
	if cancel_spells_to_check:contains(spell.english) or cancel_types_to_check:contains(spell.type) then
		if spell.english == 'Spectral Jig' and buffactive['Sneak'] then
			cast_delay(.2)
			send_command('cancel sneak')
			add_tick_delay(.2)
		elseif spell.english == 'Valiance' and buffactive['Vallation'] then
			cast_delay(.2)
			send_command('cancel vallation')
			add_tick_delay(.2)
		elseif (spell.english:startswith('Monomi') or (spell.english == 'Sneak' and spell.target.type == 'SELF')) and buffactive['Sneak'] then
			send_command('cancel sneak')
		elseif spell.english == ('Stoneskin') or spell.english == ('Diamondhide') or spell.english == ('Magic Barrier') then
			send_command('@wait 1;cancel stoneskin')
		elseif spell.english == 'Utsusemi: Ni' and player.main_job == 'NIN' and lastshadow == 'Utsusemi: San' then
			if buffactive['Copy Image (4+)'] and conserveshadows then
				add_to_chat(123,'Abort: You have four or more shadows.')
				eventArgs.cancel = true
			else
				send_command('@wait '..utsusemi_ni_cancel_delay..';cancel copy image*')
			end
		elseif spell.english == 'Utsusemi: Ichi' and lastshadow ~= 'Utsusemi: Ichi' then
			if (buffactive['Copy Image (3)'] or buffactive['Copy Image (4+)']) and conserveshadows then
				add_to_chat(123,'Abort: You have three or more shadows.')
				eventArgs.cancel = true
			else
				send_command('@wait '..utsusemi_cancel_delay..';cancel copy image*')
			end
		elseif (spell.english == 'Trance' or spell.type=='Waltz') and buffactive['Saber Dance'] then
			cast_delay(0.2)
			send_command('cancel saber dance')
			add_tick_delay(0.2)
		elseif spell.type=='Samba' and buffactive['Fan Dance'] then
			cast_delay(0.2)
			send_command('cancel fan dance')
			add_tick_delay(0.2)
		end
	end
end


function notify_buffs(buff, gain)
	if state.NotifyBuffs.value and NotifyBuffs:contains(buff) then
		if gain then
			windower.chat.input('/p '..buff:ucfirst()..' on me!')
		else
			windower.chat.input('/p '..buff:ucfirst()..' is off now.')
		end
	end
end

-- Function to make auto-translate work in windower.
-- Usage: windower.add_to_chat(207, 'Test ' .. auto_translate(command))

do
	local cache = {}
	auto_translate = function(term)
		if not cache[term] then
			local entry = res.auto_translates:with('english', term)
			cache[term] = entry and 'CH>HC':pack(0xFD, 0x0202, entry.id, 0xFD) or term
		end

		return cache[term]
	end
end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions for changing spells and target types in an automatic manner.
-------------------------------------------------------------------------------------------------------------------

waltz_tp_cost = {['Curing Waltz'] = 200, ['Curing Waltz II'] = 350, ['Curing Waltz III'] = 500, ['Curing Waltz IV'] = 650, ['Curing Waltz V'] = 800}

-- Utility function for automatically adjusting the waltz spell being used to match HP needs and TP limits.
-- Handle spell changes before attempting any precast stuff.
function refine_waltz(spell, spellMap, eventArgs)
	if not state.RefineWaltz.value or spell.type ~= 'Waltz' then return false end

	local effective_tp = player.tp
	if state.DefenseMode.value == 'None' and uses_waltz_legs then
		effective_tp = player.tp + 50
	end

	if effective_tp < 200 then
		add_to_chat(123, 'Abort: Insufficient TP ['..tostring(player.tp)..'] to waltz.')
		eventArgs.cancel = true
		return true
	end

	-- Don't modify anything for Healing Waltz or Divine Waltzes
	if spell.english == "Healing Waltz" or spell.english == "Divine Waltz" or spell.english == "Divine Waltz II" then
		return false
	end

	local newWaltz = spell.english
	local waltzID

	local missingHP

	-- If curing ourself, get our exact missing HP
	if spell.target.type == "SELF" then
		missingHP = player.max_hp - player.hp
	-- If curing someone in our alliance, we can estimate their missing HP
	elseif spell.target.isallymember then
		local target = find_player_in_alliance(spell.target.name)
		local est_max_hp = target.hp / (target.hpp/100)
		missingHP = math.floor(est_max_hp - target.hp)

		if player.main_job == 'DNC' and state.Buff['Contradance'] then
			missingHP = missingHP / 2
		end
	end

	-- If we have an estimated missing HP value, we can adjust the preferred tier used.
	if missingHP == nil then return end

	local abil_recasts = windower.ffxi.get_ability_recasts()
	if player.main_job == 'DNC' then
		if missingHP < 40 and spell.target.name == player.name then
			-- Not worth curing yourself for so little.
			-- Don't block when curing others to allow for waking them up.
			add_to_chat(123,'Abort: You have full HP!')
			eventArgs.cancel = true
			return true
		elseif missingHP < 200 then
			if abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
				waltzID = 190
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			end
		elseif missingHP < 600 then
			if abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			elseif abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			elseif abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
				waltzID = 190
			end
		elseif missingHP < 1100 then
			if abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			elseif abil_recasts[188] < latency then
				newWaltz = 'Curing Waltz IV'
				waltzID = 193
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			end
		elseif state.AutoContradanceMode.value and abil_recasts[229] < latency then
			eventArgs.cancel = true
			windower.chat.input('/ja "Contradance" <me>')
			windower.chat.input:schedule(.5,'/ja "Curing Waltz III" '..spell.target.raw..'')
			return true
		elseif missingHP < 1500 then
			if abil_recasts[188] < latency then
				newWaltz = 'Curing Waltz IV'
				waltzID = 193
			elseif abil_recasts[189] < latency then
				newWaltz = 'Curing Waltz V'
				waltzID = 311
			elseif abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			end
		else
			if abil_recasts[189] < latency then
				newWaltz = 'Curing Waltz V'
				waltzID = 311
			elseif abil_recasts[188] < latency then
				newWaltz = 'Curing Waltz IV'
				waltzID = 193
			elseif abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			end
		end
	elseif player.sub_job == 'DNC' then
		if missingHP < 40 and spell.target.name == player.name then
			-- Not worth curing yourself for so little.
			-- Don't block when curing others to allow for waking them up.
			add_to_chat(123,'Abort: You have full HP!')
			eventArgs.cancel = true
			return true
		elseif missingHP < 150 then
			if abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
				waltzID = 190
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			end
		elseif missingHP < 300 then
			if abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			elseif abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			end
		else
			if abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
				waltzID = 192
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
				waltzID = 191
			end
		end
	else
		-- Not dnc main or sub; bail out
		return false
	end

	local tpCost = waltz_tp_cost[newWaltz]
	local downgrade

	-- Downgrade the spell to what we can afford
	if effective_tp < tpCost and not buffactive.trance then
		--[[ Costs:
			Curing Waltz:     200 TP
			Curing Waltz II:  350 TP
			Curing Waltz III: 500 TP
			Curing Waltz IV:  650 TP
			Curing Waltz V:   800 TP
			Divine Waltz:     400 TP
			Divine Waltz II:  800 TP
		--]]
		if effective_tp < 350 and abil_recasts[217] < latency then
			newWaltz = 'Curing Waltz'
		elseif effective_tp < 500 then
			if abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
			elseif abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
			end
		elseif effective_tp < 650 then
			if abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
			elseif abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
			end
		elseif effective_tp < 800 then
			if abil_recasts[188] < latency then
				newWaltz = 'Curing Waltz IV'
			elseif abil_recasts[187] < latency then
				newWaltz = 'Curing Waltz III'
			elseif abil_recasts[186] < latency then
				newWaltz = 'Curing Waltz II'
			elseif abil_recasts[217] < latency then
				newWaltz = 'Curing Waltz'
			end
		end

		downgrade = 'Insufficient TP ['..tostring(player.tp)..']. Downgrading to '..newWaltz..'.'
	end


	if newWaltz ~= spell.english then
		windower.chat.input('/ja "'..newWaltz..'" '..tostring(spell.target.raw))
		if downgrade then
			add_to_chat(122, downgrade)
		end
		eventArgs.cancel = true
		add_to_chat(122,'Trying to cure '..tostring(missingHP)..' HP using '..newWaltz..'.')
		return true
	end
end

-------------------------------------------------------------------------------------------------------------------
-- Environment utility functions.
-------------------------------------------------------------------------------------------------------------------

-- Call these function with a list of equipment slots to check ('head', 'neck', 'body', etc)
-- Returns true if any of the specified slots are currently encumbered.
-- Returns false if all specified slots are unencumbered.
function is_encumbered(...)
	local check_list = {...}
	-- Compensate for people passing a table instead of a series of strings.
	if type(check_list[1]) == 'table' then
		check_list = check_list[1]
	end
	local check_set = S(check_list)

	for slot_id,slot_name in pairs(gearswap.default_slot_map) do
		if check_set:contains(slot_name) then
			if gearswap.encumbrance_table[slot_id] then
				return true
			end
		end
	end

	return false
end

-------------------------------------------------------------------------------------------------------------------
-- Elemental gear utility functions.
-------------------------------------------------------------------------------------------------------------------

-- Function to get an appropriate obi/cape/ring for the current action.
function set_elemental_obi_cape_ring(spell, spellMap) -- Thank you Lili <3
	if spell.element == 'None' then return end

	if spell.element == world.weather_element or spell.element == world.day_element and item_available("Twilight Cape") then
		gear.ElementalCape.name = "Twilight Cape"
	else
		gear.ElementalCape.name = gear.default.obi_back
	end

	if spell.element == world.day_element and spell.english ~= 'Impact' and not spell.skill == 'Divine Magic' and item_available("Zodiac Ring") then
		gear.ElementalRing.name = "Zodiac Ring"
	else
		gear.ElementalRing.name = gear.default.obi_ring
	end

	local distance = spell.target.distance - spell.target.model_size
	local orpheus_intensity = 0
	local day_potency = (spell.element == world.day_element and 10) or (spell.element == data.elements.weak_to[world.day_element] and -10) or 0
	local weather_potency = (spell.element == world.weather_element and data.weather_bonus_potency[world.weather_intensity]) or (data.elements.weak_to[world.weather_element] and (data.weather_bonus_potency[world.weather_intensity] * -1)) or 0

	if item_available("Orpheus's Sash") then
		orpheus_intensity = (16 - math.min(math.max(distance,1),15))
		orpheus_intensity = orpheus_intensity * (1 + ( day_potency * 1/5 + weather_potency * 1/3 ) /100)
	end

	if spell.english:endswith('helix') or spell.english:endswith('helix II') then
		if orpheus_intensity > 2 then
			equip({waist="Orpheus's Sash"})
		end
		return
	end

	local single_obi_intensity = 0
	local hachirin_intensity = 0

	if item_available(data.elements.obi_of[spell.element]) then
		if spell.element == world.day_element then
			single_obi_intensity = 10
		end
		if spell.element == world.weather_element then
			single_obi_intensity = single_obi_intensity + data.weather_bonus_potency[world.weather_intensity]
		end
	end

	if item_available('Hachirin-no-Obi') then
		hachirin_intensity = day_potency + weather_potency
	end

	if hachirin_intensity >= single_obi_intensity and hachirin_intensity >= orpheus_intensity and hachirin_intensity >= 5 then
		equip({waist="Hachirin-no-Obi"})
	elseif single_obi_intensity >= orpheus_intensity and single_obi_intensity >= 5 then
		equip({waist=data.elements.obi_of[spell.element]})
	elseif orpheus_intensity >= 2 then
		equip({waist="Orpheus's Sash"})
	end
end

function check_item_dependant_spells(spell, spellMap)
	if spell.english == 'Dispelga' then
		equip({main="Daybreak"})
	elseif spell.english == 'Honor March' then
		equip({range="Marsyas"})
	elseif spell.english == 'Aria of Passion' then
		equip({range="Loughnashade"})
	elseif spell.english == 'Impact' then
		if item_equippable("Crepuscular Cloak") then
			equip({head=empty,body="Crepuscular Cloak"})
		else
			equip({head=empty,body="Twilight Cloak"})
		end
	end
end


-- Function to get the appropriate fast cast and/or recast staves for the current spell.
--[[
function set_elemental_staff(spell)
	if spell.action_type ~= 'Magic' then
		return
	end

	gear.FastcastStaff.name = get_elemental_item_name("fastcast_staff", S{spell.element}) or gear.default.fastcast_staff  or ""
	gear.RecastStaff.name   = get_elemental_item_name("recast_staff", S{spell.element})   or gear.default.recast_staff    or ""
end
]]

-- Gets the name of an elementally-aligned piece of gear within the player's
-- inventory that matches the conditions set in the parameters.
--
-- item_type: Type of item as specified in the elemental_map mappings.
-- EG: gorget, belt, obi, fastcast_staff, recast_staff
--
-- valid_elements: Elements that are valid for the action being taken.
-- IE: Weaponskill skillchain properties, or spell element.
--
-- restricted_to_elements: Secondary elemental restriction that limits
-- whether the item check can be considered valid.
-- EG: Day or weather elements that have to match the spell element being queried.
--
-- Returns: Nil if no match was found (either due to elemental restrictions,
-- or the gear isn't in the player inventory), or the name of the piece of
-- gear that matches the query.

-- function get_elemental_item_name(item_type, valid_elements, restricted_to_elements)
	-- local potential_elements = restricted_to_elements or data.elements.list
	-- local item_map = elements[item_type:lower()..'_of']

	-- for element in (potential_elements.it or it)(potential_elements) do
		-- if valid_elements:contains(element) and (player.inventory[item_map[element]] or player.wardrobe[item_map[element]] or player.wardrobe2[item_map[element]]) or player.wardrobe3[item_map[element]] or player.wardrobe4[item_map[element]] then
			-- return item_map[element]
		-- end
	-- end
-- end


-------------------------------------------------------------------------------------------------------------------
-- Function to easily change to a given macro set or book.  Book value is optional.
-------------------------------------------------------------------------------------------------------------------

function set_macro_page(set,book)
	page_cache = tostring(set)
	if not tonumber(set) then
		add_to_chat(123,'Error setting macro page: Set is not a valid number ('..tostring(set)..').')
		return
	end
	if set < 1 or set > 10 then
		add_to_chat(123,'Error setting macro page: Macro set ('..tostring(set)..') must be between 1 and 10.')
		return
	end

	if book then
		if not tonumber(book) then
			add_to_chat(123,'Error setting macro page: book is not a valid number ('..tostring(book)..').')
			return
		end
		if book < 1 or book > 40 then
			add_to_chat(123,'Error setting macro page: Macro book ('..tostring(book)..') must be between 1 and 40.')
			return
		end
		send_command('@input /macro book '..tostring(book)..';wait 2;input /macro set '..tostring(set))
	else
		send_command('@input /macro set '..tostring(set))
	end
end


-- Function for optionally including files if they exist.
function optional_include(filename)
	if filename:startswith('User') then
		if windower.file_exists(windower.addon_path..'Data/User/'..filename) then
			include('User/'..filename)
		else
			print('Missing optional file: User\\\\'..filename..', this is not an error, just a notification of a filename you can use to add your own custom code.')
			return false
		end
	else
		if gearswap.pathsearch({filename}) then
			include(filename)
		else
			print('Missing optional file: '..player.name..'\\\\'..filename..', this is not an error, just a notification of a filename you can use to add your own custom code.')
			return false
		end
	end
end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions for vars or other data manipulation.
-------------------------------------------------------------------------------------------------------------------

-- Attempt to locate a specified name within the current alliance.
function find_player_in_alliance(name)
	for party_index,ally_party in ipairs(alliance) do
		for player_index,_player in ipairs(ally_party) do
			if _player.name == name then
				return _player
			end
		end
	end
end

function number_of_jps(jp_tab)
	local count = 0
	for _,v in pairs(jp_tab) do
		count = count + v*(v+1)
	end
	return count/2
end

function add_table_to_chat(table)
	for k, v in pairs( table ) do
		add_to_chat(123,''..k..', '..v)
	end
end

function remove_table_value(table, value)
	for i = #table, 1, -1 do
		if table[i] == value then
			table.remove(table, i)
		end
	end
end

function get_spell_id_by_name(spell_name)
	return get_action_id_by_name(spell_name, '/ma')
end

function get_weaponskill_id_by_name(weaponskill_name)
	return get_action_id_by_name(weaponskill_name, '/ws')
end

function get_ability_id_by_name(job_ability_name)
	return get_action_id_by_name(job_ability_name, '/ja')
end

function get_action_id_by_name(action_name, action_type)
	local prefix = unify_prefix(action_type)
	return gearswap.validabils.english[prefix][action_name:lower()] or false
end

function unify_prefix(action_type)
	if action_type:startswith('/') then
		return gearswap.unify_prefix[action_type]
	else
		return gearswap.unify_prefix['/'..action_type]
	end
end

function silent_can_use(action, action_type)
	local action_type = unify_prefix(action_type)

	if silent_can_use_cache[action_type][action] then
		return silent_can_use_cache[action_type][action]
	end

	local action_id = get_action_id_by_name(action, action_type)

	if action_type == "/ma" then
		if action == "Dispelga" then
			 silent_can_use_cache["/ma"]["Dispelga"] = item_equippable("Daybreak")
		elseif action == "Honor March" then
			silent_can_use_cache["/ma"]["Honor March"] = item_equippable("Marsyas")
		elseif action == "Aria of Passion" then
			silent_can_use_cache["/ma"]["Aria of Passion"] = item_equippable("Loughnashade")
		elseif action == "Impact" then
			silent_can_use_cache["/ma"]["Impact"] = item_equippable("Crepuscular Cloak") or item_equippable("Twilight Cloak")
		end
		
		if silent_can_use_cache[action_type][action] then
			return silent_can_use_cache[action_type][action]
		end

		local available_spells = windower.ffxi.get_spells()
		local spell_jobs = copy_entry(res.spells[action_id].levels)
		
		if not available_spells[action_id] then -- Filter for spells that you do not know.
			silent_can_use_cache['/ma'][action] = false
		-- Filter for spells that you know, but do not currently have access to
		elseif (not spell_jobs[player.main_job_id] or not (spell_jobs[player.main_job_id] <= player.main_job_level or
			(spell_jobs[player.main_job_id] >= 100 and number_of_jps(player.job_points[player.main_job:lower()]) >= spell_jobs[player.main_job_id]))) and
			(not spell_jobs[player.sub_job_id] or not (spell_jobs[player.sub_job_id] <= player.sub_job_level)) then
			silent_can_use_cache['/ma'][action] = false
		else
			silent_can_use_cache['/ma'][action] = true
		end
	elseif action_type == '/ja' then
		local available_abilities = windower.ffxi.get_ability_recasts()
		if available_abilities[action_id] then
			silent_can_use_cache['/ja'][action] = true
		else
			silent_can_use_cache['/ja'][action] = false
		end
	elseif action_type == '/ws' then
		local available_ws = windower.ffxi.get_abilities().weapon_skills
		if available_ws[action_id] then
			silent_can_use_cache['/ws'][action] = true
		else
			silent_can_use_cache['/ws'][action] = false
		end
	end
	return silent_can_use_cache[action_type][action]
end

function silent_can_cast(spell)
	return silent_can_use(spell, '/ma')
end

function silent_can_ability(spell)
	return silent_can_use(spell, '/ja')
end

function silent_can_weaponskill(spell)
	return silent_can_use(spell, '/ws')
end

function can_use(spell)
	if world.in_mog_house then
		add_to_chat(123,"Abort: You are currently in a Mog House zone.")
		return false
	elseif spell.action_type == 'Magic' then
		local available_spells = windower.ffxi.get_spells()
		local spell_jobs = copy_entry(res.spells[spell.id].levels)

		-- Filter for spells that you do not know. Exclude Impact.
		if spell.name == "Impact" then
			if item_equippable('Twilight Cloak') or item_equippable('Crepuscular Cloak') then
				return true
			else
				add_to_chat(123,"Abort: [Impact] requires Twilight Cloak or Crepuscular Cloak.")
				return false
			end
		elseif spell.name == "Honor March" then
			if item_equippable('Marsyas') then
				return true
			else
				add_to_chat(123,"Abort: [Honor March] requires Marsyas.")
				return false
			end
		elseif spell.name == "Dispelga" then
			if item_equippable('Daybreak') then
				return true
			else
				add_to_chat(123,"Abort: [Dispelga] requires Daybreak.")
				return false
			end
		elseif spell.name == "Aria of Passion" then
			if item_equippable('Loughnashade') then
				return true
			else
				add_to_chat(123,"Abort: [Aria of Passion] requires Loughnashade.")
				return false
			end
		elseif not available_spells[spell.id] then
			add_to_chat(123,"Abort: You haven't learned ["..(res.spells[spell.id][language] or spell.id).."].")
			return false
		elseif spell.type == 'Ninjutsu'  then
			if player.main_job ~= 'NIN' and player.sub_job ~= 'NIN' then
				add_to_chat(123,"Abort: You don't have access to ["..(spell[language] or spell.id).."].")
				return false
			elseif not player.inventory[data.tools.tool_map[spell.english][language]] and not (player.main_job_id == 13 and player.inventory[data.tools.universal_tool_map[spell.english][language]]) then
				if player.main_job == 'NIN' and player[consumable_bag][data.tools.universal_tool_map[spell.english][language]] then --Universal tool in consumable bag
					send_command('get "'..data.tools.universal_tool_map[spell.english][language]..'" '..consumable_bag..' 99')
					windower.chat.input:schedule(1.5,'/ma "'..spell.english..'" '..spell.target.raw..'')
				elseif player[consumable_bag][data.tools.tool_map[spell.english][language]] then --Specific tool in consumable bag
					send_command('get "'..data.tools.tool_map[spell.english][language]..'" '..consumable_bag..' 99')
					windower.chat.input:schedule(1.5,'/ma "'..spell.english..'" '..spell.target.raw..'')
				elseif player.main_job == 'NIN' and player.inventory[data.tools.universal_toolbag_map[spell.english][language]] then --Universal toolbag in inventory
					windower.chat.input('/item "'..data.tools.universal_toolbag_map[spell.english][language]..'" <me>')
					windower.chat.input:schedule(4,'/ma "'..spell.english..'" '..spell.target.raw..'')
				elseif player.main_job == 'NIN' and player[consumable_bag][data.tools.universal_toolbag_map[spell.english][language]] then --Universal toolbag in consumable bag
					send_command('get "'..data.tools.universal_toolbag_map[spell.english][language]..'" '..consumable_bag..' 1')
					windower.chat.input:schedule(1.5,'/item "'..data.tools.universal_toolbag_map[spell.english][language]..'" <me>')
					windower.chat.input:schedule(5.5,'/ma "'..spell.english..'" '..spell.target.raw..'')
				elseif player.inventory[data.tools.toolbag_map[spell.english][language]] then --Specific toolbag in Inventory
					windower.chat.input('/item "'..data.tools.toolbag_map[spell.english][language]..'" <me>')
					windower.chat.input:schedule(4,'/ma "'..spell.english..'" '..spell.target.raw..'')
				elseif player[consumable_bag][data.tools.toolbag_map[spell.english][language]] then --Specific toolbag in bag
					send_command('get "'..data.tools.toolbag_map[spell.english][language]..'" '..consumable_bag..' 1')
					windower.chat.input:schedule(1.5,'/item "'..data.tools.universal_toolbag_map[spell.english][language]..'" <me>')
					windower.chat.input:schedule(5.5,'/ma "'..spell.english..'" '..spell.target.raw..'')
				else
					add_to_chat(123,"Abort: You don't have the proper ninja tool available.")
				end
				return false
			end
		-- Filter for spells that you know, but do not currently have access to
		elseif (not spell_jobs[player.main_job_id] or not (spell_jobs[player.main_job_id] <= player.main_job_level or
			(spell_jobs[player.main_job_id] >= 100 and number_of_jps(player.job_points[__raw.lower(res.jobs[player.main_job_id].ens)]) >= spell_jobs[player.main_job_id]) ) ) and
			(not spell_jobs[player.sub_job_id] or not (spell_jobs[player.sub_job_id] <= player.sub_job_level)) then
			add_to_chat(123,"Abort: You don't have access to ["..(res.spells[spell.id][language] or spell.id).."].")
			return false
		-- At this point, we know that it is technically castable by this job combination if the right conditions are met.
		elseif player.main_job == 'SCH'then
			if (spell_jobs[player.sub_job_id] and spell_jobs[player.sub_job_id] <= player.sub_job_level) or state.Buff['Enlightenment'] then
				return true
			elseif data.spells.addendum_white:contains(spell.english) and not state.Buff['Addendum: White'] then
				if state.AutoArts.value and not state.Buff['Addendum: White'] and not silent_check_amnesia() and get_current_stratagem_count() > 0 then
					if state.Buff['Light Arts'] then
						windower.chat.input('/ja "Addendum: White" <me>')
						windower.chat.input:schedule(1.1,'/ma "'..spell.english..'" '..spell.target.raw..'')
						add_tick_delay(1.1)
					else
						local abil_recasts = windower.ffxi.get_ability_recasts()
						if abil_recasts[228] < latency then
							windower.chat.input('/ja "Light Arts" <me>')
							windower.chat.input:schedule(1.1,'/ja "Addendum: White" <me>')
							windower.chat.input:schedule(2.2,'/ma "'..spell.english..'" '..spell.target.raw..'')
							add_tick_delay(2.2)
						else
							add_to_chat(123,"Abort: Addendum: White required for ["..spell.name.."].")
						end
					end
				else
					add_to_chat(123,"Abort: Addendum: White required for ["..spell.name.."].")
				end
				return false
			elseif data.spells.addendum_black:contains(spell.english) and not state.Buff['Addendum: Black'] then
				if state.AutoArts.value and not state.Buff['Addendum: Black'] and not silent_check_amnesia() and get_current_stratagem_count() > 0 then
					if state.Buff['Dark Arts'] then
						windower.chat.input('/ja "Addendum: Black" <me>')
						windower.chat.input:schedule(1.1,'/ma "'..spell.english..'" '..spell.target.raw..'')
						add_tick_delay(1.1)
					else
						local abil_recasts = windower.ffxi.get_ability_recasts()
						if abil_recasts[232] < latency then
							windower.chat.input('/ja "Dark Arts" <me>')
							windower.chat.input:schedule(1.1,'/ja "Addendum: Black" <me>')
							windower.chat.input:schedule(2.2,'/ma "'..spell.english..'" '..spell.target.raw..'')
							add_tick_delay(2.2)
						else
							add_to_chat(123,"Abort: Addendum: Black required for ["..spell.name.."].")
						end
					end
				else
					add_to_chat(123,"Abort: Addendum: Black required for ["..spell.name.."].")
				end
				return false
			end
		elseif player.sub_job_id == 20 and ((data.spells.addendum_white:contains(spell.english) and not buffactive[401] and not buffactive[416]) or
			(data.spells.addendum_black:contains(spell.english) and not buffactive[402] and not buffactive[416])) and
			not (spell_jobs[player.main_job_id] and (spell_jobs[player.main_job_id] <= player.main_job_level or
			(spell_jobs[player.main_job_id] >= 100 and number_of_jps(player.job_points[__raw.lower(res.jobs[player.main_job_id].ens)]) >= spell_jobs[player.main_job_id]) ) ) then

			if data.spells.addendum_white:contains(spell.english) then
				if state.AutoArts.value and not buffactive["Addendum: White"] and not silent_check_amnesia() and get_current_stratagem_count() > 0 then
					if state.Buff['Light Arts'] then
						windower.chat.input('/ja "Addendum: White" <me>')
						windower.chat.input:schedule(1.1,'/ma "'..spell.english..'" '..spell.target.raw..'')
						add_tick_delay(1.1)
					else
						local abil_recasts = windower.ffxi.get_ability_recasts()
						if abil_recasts[228] < latency then
							windower.chat.input('/ja "Light Arts" <me>')
							windower.chat.input:schedule(1.1,'/ja "Addendum: White" <me>')
							windower.chat.input:schedule(2.2,'/ma "'..spell.english..'" '..spell.target.raw..'')
							add_tick_delay(2.2)
						end
					end
				else
					add_to_chat(123,"Abort: Addendum: White required for ["..(res.spells[spell.id][language] or spell.id).."].")
				end
			end
			if data.spells.addendum_black:contains(spell.english) then
				if state.AutoArts.value and not buffactive["Addendum: Black"] and not silent_check_amnesia() and get_current_stratagem_count() > 0 then
					if buffactive["Dark Arts"] then
						windower.chat.input('/ja "Addendum: Black" <me>')
						windower.chat.input:schedule(1.1,'/ma "'..spell.english..'" '..spell.target.raw..'')
						add_tick_delay(1.1)
					else
						local abil_recasts = windower.ffxi.get_ability_recasts()
						if abil_recasts[232] < latency then
							windower.chat.input('/ja "Dark Arts" <me>')
							windower.chat.input:schedule(1.1,'/ja "Addendum: Black" <me>')
							windower.chat.input:schedule(2.2,'/ma "'..spell.english..'" '..spell.target.raw..'')
							add_tick_delay(2.2)
						end
					end
				else
					add_to_chat(123,"Abort: Addendum: Black required for ["..(res.spells[spell.id][language] or spell.id).."].")
				end
			end
			return false
		elseif spell.type == 'BlueMagic' and not ((player.main_job_id == 16 and table.contains(windower.ffxi.get_mjob_data().spells,spell.id))
			or data.spells.unbridled:contains(spell.english)) and
			not (player.sub_job_id == 16 and table.contains(windower.ffxi.get_sjob_data().spells,spell.id)) then
			-- This code isn't hurting anything, but it doesn't need to be here either.
			add_to_chat(123,"Abort: You haven't set ["..(res.spells[spell.id][language] or spell.id).."].")
			return false
		end
	elseif spell.type == 'WeaponSkill' or spell.action_type == 'Ability' then
		local available = windower.ffxi.get_abilities()
		if spell.type == 'WeaponSkill' and not S(available.weapon_skills)[spell.id] then
			add_to_chat(123,"Abort: You don't have access to ["..(res.weapon_skills[spell.id][language] or spell.id).."].")
			return false
		elseif spell.action_type == 'Ability' then
			if not S(available.job_abilities)[spell.id] then
				add_to_chat(123,"Abort: You don't have access to ["..(res.job_abilities[spell.id][language] or spell.id).."].")
				return false
			elseif spell.type == 'CorsairShot' and not player.inventory['Trump Card'] then
				if player.inventory['Trump Card Case'] then
					windower.chat.input('/item "Trump Card Case" <me>')
				elseif player.satchel['Trump Card Case'] then
					send_command('get "Trump Card Case" '..consumable_bag)
					windower.chat.input:schedule(1.5,'/item "Trump Card Case" <me>')
				end
				return false
			end
		end
	end

	return true
end

-- buff_set is a set of buffs in a library table (any of S{}, T{} or L{}).
-- This function checks if any of those buffs are present on the player.
function has_any_buff_of(buff_set)
	return buff_set:any(
		-- Returns true if any buff from buff set that is sent to this function returns true:
		function (b) return buffactive[b] end
	)
end

function buff_duration(buff_id)
	for i in pairs(player.buff_details) do
		if player.buff_details[i] then
			if player.buff_details[i].id == buff_id then
				return player.buff_details[i].duration
			end
		end
	end
	return 0
end


-- Invert a table such that the keys are values and the values are keys.
-- Use this to look up the index value of a given entry.
function invert_table(t)
	if t == nil then error('Attempting to invert table, received nil.', 2) end

	local i={}
	for k,v in pairs(t) do
		i[v] = k
	end
	return i
end


-- Gets sub-tables based on baseSet from the string str that may be in dot form
-- (eg: baseSet=sets, str='precast.FC', this returns the table sets.precast.FC).
function get_expanded_set(baseSet, str)
	local cur = baseSet
	for i in str:gmatch("[^.]+") do
		if cur then
			cur = cur[i]
		end
	end

	return cur
end

function copy_entry(tab)
	if not tab then return nil end
	local ret = setmetatable(table.reassign({},tab),getmetatable(tab))
	return ret
end

-------------------------------------------------------------------------------------------------------------------
-- Utility functions data and event tracking.
-------------------------------------------------------------------------------------------------------------------

-- This is a function that can be attached to a registered event for 'time change'.
-- It will send a call to the update() function if the time period changes.
-- It will also call job_time_change when any of the specific time class values have changed.
-- To activate this in your job lua, add this line to your user_setup function:
-- windower.register_event('time change', time_change)
--
-- Variables it sets: classes.Daytime, and classes.DuskToDawn.  They are set to true

--Find out if an item is equippable by item name.
function item_equippable(item)
	local item_id = get_item_id_by_name(item)
	if item_id and res.items[item_id].jobs:contains(player.main_job_id) then
		return true
	else
		return false
	end
end

function item_available(item)
	if player.inventory[item] or player.wardrobe[item] or player.wardrobe2[item] or player.wardrobe3[item] or player.wardrobe4[item] or player.wardrobe5[item] or player.wardrobe6[item] or player.wardrobe7[item] or player.wardrobe8[item] or player.satchel[item] then
		return true
	else
		return false
	end
end

function item_owned(item)
	if player.inventory[item] or player.wardrobe[item] or player.wardrobe2[item] or player.wardrobe3[item] or player.wardrobe4[item] or player.wardrobe5[item] or player.wardrobe6[item] or player.wardrobe7[item] or player.wardrobe8[item] or player.safe[item] or player.safe2[item] or player.storage[item] or player.locker[item] or player.satchel[item] or player.sack[item] or player.case[item] then
		return true
	else
		return false
	end
end

function check_disable(spell, spellMap, eventArgs)

	if player.hp == 0 then
		add_to_chat(123,'Abort: You are dead.')
		eventArgs.cancel = true
		return true
	elseif buffactive.terror then
		add_to_chat(123,'Abort: You are terrorized.')
		eventArgs.cancel = true
		return true
	elseif buffactive.petrification then
		add_to_chat(123,'Abort: You are petrified.')
		eventArgs.cancel = true
		return true
	elseif buffactive.sleep or buffactive.Lullaby then
		add_to_chat(123,'Abort: You are asleep.')
		eventArgs.cancel = true
		return true
	elseif buffactive.stun then
		add_to_chat(123,'Abort: You are stunned.')
		eventArgs.cancel = true
		return true
	else
		return false
	end

end

function silent_check_disable()

	if buffactive.terror or buffactive.petrification or buffactive.sleep or buffactive.Lullaby or buffactive.stun then
		return true
	else
		return false
	end

end

-- Checks doom, returns true if we're going to cancel and use an or cursna.
function check_doom(spell, spellMap, eventArgs)
	if buffactive.doom and state.AutoRemoveDoomMode.value and not cursna_exceptions:contains(spell.english) then

		if (buffactive.mute or buffactive.Omerta or buffactive.silence) or not (silent_can_cast("Cursna") and windower.ffxi.get_spell_recasts()[20] < spell_latency) then
			if state.AutoHolyWaterMode.value and not buffactive.muddle then
				if player.inventory['Hallowed Water'] then
					windower.chat.input('/item "Hallowed Water" <me>')
					add_to_chat(123,'Abort: You are doomed, using Hallowed Water instead.')
					eventArgs.cancel = true
					return true
				elseif player.inventory['Holy Water'] or player.satchel['Holy Water'] then
					windower.chat.input('/item "Holy Water" <me>')
					add_to_chat(123,'Abort: You are doomed, using Holy Water instead.')
					eventArgs.cancel = true
					return true
				elseif buffactive.silence then
					if player.inventory['Echo Drops'] or player.satchel['Echo Drops'] then
						windower.chat.input('/item "Echo Drops" <me>')
						eventArgs.cancel = true
						return true
					elseif player.inventory["Remedy"] then
						windower.chat.input('/item "Remedy" <me>')
						eventArgs.cancel = true
						return true
					end
					return false
				end
			end
		elseif silent_can_cast("Cursna") then
			windower.chat.input('/ma "Cursna" <me>')
			add_to_chat(123,'Abort: You are doomed, using Cursna instead.')
			eventArgs.cancel = true
			return true
		end
	else
		return false
	end
	return false
end

function just_acted(spell, spellMap, eventArgs)
	if spell and spell.english == prepared_action then
		cancel_spell()
		eventArgs.cancel = true
		return true
	elseif os.clock() < next_cast then
		if eventArgs and not state.RngHelper.value and state.MiniQueue.value and not (spell.type:startswith('BloodPact') and state.Buff["Astral Conduit"]) then
			cancel_spell()
			eventArgs.cancel = true
			delayed_cast = spell.english or ''
			delayed_target = spell.target.id or ''
		end
		return true
	else
		return false
	end
end

windower.raw_register_event('incoming chunk', function(id, data)
	if state.MiniQueue.value and id == 0x029 then
		local action = packets.parse('incoming', data)
		if action.message == 17 or action.message == 18 then
			next_cast = 0
			add_tick_delay()
		end
	end
end)

function check_amnesia(spell, spellMap, eventArgs)

	if spell.type == 'WeaponSkill' or spell.action_type == 'Ability' then

		if buffactive.amnesia then
			add_to_chat(123,'Abort: You have Amnesia.')
			eventArgs.cancel = true
			return true
		elseif buffactive.impairment then
			add_to_chat(123,'Abort: Your abilities are restricted.')
			eventArgs.cancel = true
			return true
		else
			return false
		end

	else
		return false
	end
end

function silent_check_amnesia()

	if buffactive.amnesia or buffactive.impairment then
		return true
	else
		return false
	end

end

function check_silence(spell, spellMap, eventArgs)

	if spell.action_type == 'Magic' then

		if buffactive.mute then
			add_to_chat(123,'Abort: You are muted.')
			eventArgs.cancel = true
			return true
		elseif buffactive.Omerta then
			add_to_chat(123,'Abort: Your magic is restricted.')
			eventArgs.cancel = true
			return true
		elseif buffactive.silence then
			if buffactive.paralysis then
				if player.inventory["Remedy"] then
					send_command('input /item "Remedy" <me>')
				elseif player.inventory['Echo Drops'] or player.satchel['Echo Drops'] then
					send_command('input /item "Echo Drops" <me>')
				else
					add_to_chat(123,'Abort: You are silenced.')
				end
			else
				if player.inventory['Echo Drops'] or player.satchel['Echo Drops'] then
					send_command('input /item "Echo Drops" <me>')
				elseif player.inventory["Remedy"] then
					send_command('input /item "Remedy" <me>')
				else
					add_to_chat(123,'Abort: You are silenced.')
				end
			end

			eventArgs.cancel = true
			return true
		else
			return false
		end

	else
		return false
	end
end

function silent_check_silence()

	if buffactive.mute or buffactive.Omerta then
		return true

	elseif buffactive.silence then
			if player.inventory['Echo Drops'] or player.satchel['Echo Drops'] then
				windower.chat.input('/item "Echo Drops" <me>')
			elseif player.inventory["Remedy"] then
				windower.chat.input('/item "Remedy" <me>')
			end
			return true
	else
		return false
	end
end

function check_recast(spell, spellMap, eventArgs)
		if spell.action_type == 'Ability' and spell.type ~= 'WeaponSkill' then
			if spell.recast_id == 231 or spell.recast_id == 255 or spell.recast_id == 102 or spell.recast_id == 195 then return false end
			local abil_recasts = windower.ffxi.get_ability_recasts()
			if not abil_recasts[spell.recast_id] then
				add_to_chat(123,"Abort: You don't have access to ["..spell.english.."].")
				eventArgs.cancel = true
				return true
			elseif abil_recasts[spell.recast_id] > latency then
				if spell.english == "Lunge" and abil_recasts[241] < latency then
					eventArgs.cancel = true
					send_command('@input /ja "Swipe" <t>')
					return true
				else
					add_to_chat(123,'Abort: ['..spell.english..'] waiting on recast. ('..seconds_to_clock(abil_recasts[spell.recast_id])..')')
					eventArgs.cancel = true
					return true
				end
			else
				return false
			end
		elseif spell.action_type == 'Magic' then
			local spell_recasts = windower.ffxi.get_spell_recasts()
			if (spell_recasts[spell.recast_id] > spell_latency) then
				if stepdown(spell, eventArgs) then
					return true
				else
					add_to_chat(123,'Abort: ['..spell.english..'] waiting on recast. ('..seconds_to_clock(spell_recasts[spell.recast_id]/60)..')')
					eventArgs.cancel = true
					return true
				end
			else
				return false
			end
		else
			return false
		end

end

function check_cost(spell, spellMap, eventArgs)
	local spellCost = actual_cost(spell)

	if spell.action_type == 'Magic' and player.mp < spellCost then
		if stepdown(spell, eventArgs) then
			return true
		else
			add_to_chat(123,'Abort: '..spell.english..' costs more MP. ('..player.mp..'/'..spellCost..')')
			cancel_spell()
			eventArgs.cancel = true
			return true
		end
	elseif spell.type:startswith('BloodPact') and not state.Buff["Astral Conduit"] and player.mp < spellCost then
		add_to_chat(123,'Abort: '..spell.english..' costs more MP. ('..player.mp..'/'..spellCost..')')
		cancel_spell()
		eventArgs.cancel = true
		return true
	else
		return false
	end
end

function check_warps(spell, spellMap, eventArgs)
	if spell.target.type == 'SELF' and spell.english:contains('Warp') then
		if world.area == 'Hazhalm Testing Grounds' and player.inventory['Glowing Lamp'] then
			cancel_spell()
			eventArgs.cancel = true
			add_to_chat(123,"Abort: Drop your Glowing Lamp, you don't want to lose your plasm!")
			return true
		end
	end
	return false
end

function check_spell_targets(spell, spellMap, eventArgs)
	if spellMap == 'Cure' or spellMap == 'Curaga' then
		if spell.target.distance > 21 and spell.target.type == 'PLAYER' then
			cancel_spell()
			eventArgs.cancel = true
			add_to_chat(123,'Target out of range, too far to heal!')
			return true
		elseif spell.english:startswith('Curaga') and spell.target.type == 'PLAYER' and not spell.target.in_party then
			if (state.Buff['Light Arts'] or state.Buff['Addendum: White']) then
				if get_current_stratagem_count() > 0 then
					local number = spell.english:match('Curaga ?%a*'):sub(7) or ''
					cancel_spell()
					eventArgs.cancel = true
					if buffactive['Accession'] then
						windower.chat.input('/ma "Cure'..number..'" '..spell.target.name..'')
					else
						windower.chat.input('/ja "Accession" <me>')
						windower.chat.input:schedule(1.1,'/ma "Cure'..number..'" '..spell.target.name..'')
						add_tick_delay(1.2)
					end
				else
					cancel_spell()
					eventArgs.cancel = true
					windower.add_to_chat(123,"Error: Not enough Stratagems to convert Curaga to Accesion Cure.")
				end
			else
				cancel_spell()
				eventArgs.cancel = true
				windower.add_to_chat(123,"Error: You can't Curaga outside of party.")
			end
			return true
		end
	elseif state.AdjustTargets.value and not spell.targets.Enemy and spell.target.type == 'MONSTER' then
		cancel_spell()
		eventArgs.cancel = true
		if spell.targets.Ally then
			windower.chat.input('/ma "'..spell.name..'" <stal>')
		elseif spell.targets.Party or spell.type == 'BardSong' or spell.english:startswith('Indi') then
			windower.chat.input('/ma "'..spell.name..'" <stpt>')
		elseif spell.targets.Self then
			windower.chat.input('/ma "'..spell.name..'" <me>')
		end
		return true
	else
		return false
	end
end

function check_abilities(spell, spellMap, eventArgs)
	if spell.action_type == 'Ability' then
		if spell.english == 'Seigan' then
			if buffactive['Seigan'] and windower.ffxi.get_ability_recasts()[133] < latency then
				eventArgs.cancel = true
				windower.chat.input('/ja "Third Eye" <me>')
				return true
			end
		elseif spell.type == 'Step' then
			if player.status == 'Idle' and windower.ffxi.get_ability_recasts()[220] and spell.target and spell.target.valid_target and spell.target.spawn_type == 16 and spell.target.distance < (3.2 + player.target.model_size) and player.tp > 99 then
				packets.inject(packets.new('outgoing', 0x1a, {
					['Target'] = spell.target.id,
					['Target Index'] = spell.target.index,
					['Category']     = 0x02,
				}))

				if state.IdleStep.value then
					send_command:schedule(1,'input /attack off')
				end
				return true
			end
		elseif data.abilities.white_stratagems:contains(spell.english) then
			if state.Buff['Dark Arts'] or state.Buff['Addendum: Black'] then
				windower.chat.input('/ja "'..data.abilities.white_to_black_stratagems[spell.english]..'" <me>')
				eventArgs.cancel = true
				return true
			elseif spell.english == 'Light Arts' then
				if state.Buff['Light Arts'] then
					eventArgs.cancel = true
					windower.chat.input('/ja "Addendum: White" <me>')
					return true
				end
			end
		elseif data.abilities.black_stratagems:contains(spell.english) then
			if state.Buff['Light Arts'] or state.Buff['Addendum: White'] then
				windower.chat.input('/ja "'..data.abilities.black_to_white_stratagems[spell.english]..'" <me>')
				eventArgs.cancel = true
				return true
			elseif spell.english == 'Dark Arts' then
				if state.Buff['Dark Arts'] then
					eventArgs.cancel = true
					windower.chat.input('/ja "Addendum: Black" <me>')
					return true
				end
			end
		end
	end

	return false
end

function stepdown(spell, eventArgs)
	if spell_stepdown[spell.english] then
		eventArgs.cancel = true
		windower.chat.input('/ma "'..spell_stepdown[spell.english]..'" '..spell.target.raw..'')
		return true
	else
		return false
	end
end

function actual_cost(spell)
	if buffactive["Manafont"] or buffactive["Manawell"] then
		return 0
	end

	local spell_table

	if type(spell) == "table" then
		spell_table = spell
	elseif type(spell) == 'string' then
		spell_table = res.spells[get_spell_id_by_name(spell)]
	elseif type(spell) == 'number' then
		spell_table = res.spells[spell]
	else
		return false
	end

	local cost = spell_table.mp_cost
	if spell_table.type=="WhiteMagic" then
		if buffactive["Penury"] then
			return cost*.5
		elseif state.Buff['Light Arts'] or state.Buff['Addendum: White'] then
			return cost*.9
		elseif state.Buff['Dark Arts'] or state.Buff['Addendum: Black'] then
			return cost*1.1
		end
	elseif spell_table.type=="BlackMagic" then
		if buffactive["Parsimony"] then
			return cost*.5
		elseif state.Buff['Dark Arts'] or state.Buff['Addendum: Black'] then
			return cost*.9
		elseif state.Buff['Light Arts'] or state.Buff['Addendum: White'] then
			return cost*1.1
		end
	end
	return cost
end

function check_nuke()
	if state.AutoNukeMode.value and player.target.type == "MONSTER" then
		local spell = res.spells:with('name',autonuke)
		local spell_recasts = windower.ffxi.get_spell_recasts()
		if spell_recasts[spell.id] < spell_latency then
			windower.chat.input('/ma '..autonuke..' <t>')
			add_tick_delay()
			return true
		else
			return false
		end
	else
		return false
	end
end

function check_buff()
	if state.AutoBuffMode.value ~= 'Off' and not data.areas.cities:contains(world.area) then
		local spell_recasts = windower.ffxi.get_spell_recasts()
		for i in pairs(buff_spell_lists[state.AutoBuffMode.Value]) do
			if not buffactive[buff_spell_lists[state.AutoBuffMode.Value][i].Buff] and (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Always' or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Combat' and in_combat) or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Engaged' and player.status == 'Engaged') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'Idle' and player.status == 'Idle') or (buff_spell_lists[state.AutoBuffMode.Value][i].When == 'OutOfCombat' and not in_combat)) and spell_recasts[buff_spell_lists[state.AutoBuffMode.Value][i].SpellID] < spell_latency and silent_can_cast(buff_spell_lists[state.AutoBuffMode.Value][i].Name) then
				windower.chat.input('/ma "'..buff_spell_lists[state.AutoBuffMode.Value][i].Name..'" <me>')
				add_tick_delay()
				return true
			end
		end
	else
		return false
	end
end

function check_buffup()
	if buffup ~= '' then
		local needsbuff = false
		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_cast(buff_spell_lists[buffup][i].Name) then
				needsbuff = true
				break
			end
		end

		if not needsbuff then
			add_to_chat(217, 'All '..buffup..' buffs are up!')
			buffup = ''
			return false
		end

		local spell_recasts = windower.ffxi.get_spell_recasts()

		for i in pairs(buff_spell_lists[buffup]) do
			if not buffactive[buff_spell_lists[buffup][i].Buff] and silent_can_cast(buff_spell_lists[buffup][i].Name) and spell_recasts[buff_spell_lists[buffup][i].SpellID] < spell_latency then
				windower.chat.input('/ma "'..buff_spell_lists[buffup][i].Name..'" <me>')
				add_tick_delay()
				return true
			end
		end

		return false
	else
		return false
	end
end

function check_samba()
	if not (buffactive['Haste Samba'] or buffactive['Drain Samba'] or buffactive['Aspir Samba']) and windower.ffxi.get_ability_recasts()[216] and windower.ffxi.get_ability_recasts()[216] < latency and state.AutoSambaMode.value ~= 'Off' and player.tp > 400 then
		windower.chat.input('/ja "'..state.AutoSambaMode.value..'" <me>')
		add_tick_delay()
		return true
	else
		return false
	end
end

function check_sub()
	if state.AutoSubMode.value and not data.areas.cities:contains(world.area) then
		if player.mpp < 70 and player.tp > 999 then
			local available_ws = S(windower.ffxi.get_abilities().weapon_skills)

			if available_ws:contains(190) then
				windower.chat.input('/ws Myrkr <me>')
				add_tick_delay()
				return true
			elseif available_ws:contains(173) then
				windower.chat.input('/ws Dagan <me>')
				add_tick_delay()
				return true
			end
		end
		if (player.main_job == 'SCH' or (player.sub_job == 'SCH' and not buffactive['SJ Restriction'])) and not silent_check_amnesia() then
			local abil_recasts = windower.ffxi.get_ability_recasts()
			if abil_recasts[234] < latency then
				if buffactive['Sublimation: Complete'] then
					if player.mpp < 65 then
						windower.chat.input('/ja Sublimation <me>')
						add_tick_delay()
						return true
					end

				elseif not buffactive['Sublimation: Activated'] then
					windower.chat.input('/ja Sublimation <me>')
					add_tick_delay()
					return true
				end
			end
		end
	end
	return false
end

function check_cleanup()
	if state.AutoCleanupMode.value then
		if not state.Buff['Invisible'] then
			if player.inventory['Bead Pouch'] then
				send_command('input /item "Bead Pouch" <me>')
				add_tick_delay(2)
				return true
			elseif player.inventory['Silt Pouch'] then
				send_command('input /item "Silt Pouch" <me>')
				add_tick_delay(2)
				return true
			end

			local shard_name = {'C. Ygg. Shard ','Z. Ygg. Shard ','A. Ygg. Shard ','P. Ygg. Shard '}

			for sni, snv in ipairs(shard_name) do
				local shard_count = {'I','II','III','IV','V'}
				for sci, scv in ipairs(shard_count) do
					if player.inventory[snv..''..scv] then
						send_command('wait 3.0;input /item "'..snv..''..scv..'" <me>')
						add_tick_delay(2)
						return true
					end
				end
			end
		end

		local items = windower.ffxi.get_items()
		local moveditem = false
		if items.count_sack < items.max_sack then
			if player.inventory['Pellucid Stone'] then send_command('put "Pellucid Stone" '..currency_bag..' all') moveditem = true end
			if player.inventory['Taupe Stone'] then send_command('put "Taupe Stone" '..currency_bag..' all') moveditem = true end
			if player.inventory['Fern Stone'] then send_command('put "Fern Stone" '..currency_bag..' all') moveditem = true end
			if player.inventory['Frayed Sack (Pel)'] then send_command('put "Frayed Sack (Pel)" '..currency_bag..' all') moveditem = true end
			if player.inventory['Frayed Sack (Tau)'] then send_command('put "Frayed Sack (Tau)" '..currency_bag..' all') moveditem = true end
			if player.inventory['Frayed Sack (Fer)'] then send_command('put "Frayed Sack (Fer)" '..currency_bag..' all') moveditem = true end
			if player.inventory['Beitetsu'] then send_command('put Beitetsu '..currency_bag..' all') moveditem = true end
			if player.inventory['Beitetsu Parcel'] then send_command('put "Beitetsu Parcel" '..currency_bag..' all') moveditem = true end
			if player.inventory['Beitetsu Box'] then send_command('put "Beitetsu Box" '..currency_bag..' all') moveditem = true end
			if player.inventory['Pluton'] then send_command('put Pluton '..currency_bag..' all') moveditem = true end
			if player.inventory['Pluton Case'] then send_command('put "Pluton Case" '..currency_bag..' all') moveditem = true end
			if player.inventory['Pluton Box'] then send_command('put "Pluton Box" '..currency_bag..' all') moveditem = true end
			if player.inventory['Riftborn Boulder'] then send_command('put "Riftborn Boulder" '..currency_bag..' all') moveditem = true end
			if player.inventory['Boulder Case'] then send_command('put "Boulder Case" '..currency_bag..' all') moveditem = true end
			if player.inventory['Boulder Box'] then send_command('put "Boulder Box" '..currency_bag..' all') moveditem = true end
		end

		if not state.Capacity.value then
			if player.inventory['Mecisto. Mantle'] then send_command('put "Mecisto. Mantle" satchel') moveditem = true end
			if player.inventory['Endorsement Ring'] then send_command('put "Endorsement Ring" satchel')  moveditem = true end
			if player.inventory['Trizek Ring'] then send_command('put "Trizek Ring" satchel')  moveditem = true end
			if player.inventory['Capacity Ring'] then send_command('put "Capacity Ring" satchel') moveditem = true end
			if player.inventory['Vocation Ring'] then send_command('put "Vocation Ring" satchel')  moveditem = true end
			if player.inventory['Facility Ring'] then send_command('put "Facility Ring" satchel') moveditem = true end
			if player.inventory['Guide Beret'] then send_command('put "Guide Beret" satchel') moveditem = true end
			if player.inventory["Emporox's Ring"] then send_command('put "Emporox\'s Ring" satchel') moveditem = true end
		end

		if moveditem then add_tick_delay(2) return true end

		return false
	else
		return false
	end
end

function check_trust()
	if not moving and state.AutoTrustMode.value and not data.areas.cities:contains(world.area) and (buffactive['Reive Mark'] or buffactive['Elvorseal'] or not in_combat) then
		local party = windower.ffxi.get_party()
		if party.p5 ~= nil then return end
		local spell_recasts = windower.ffxi.get_spell_recasts()

		for k, trust_name in ipairs(trust_list) do
			local spell_id = get_spell_id_by_name(trust_name)
			local party_name = res.spells[spell_id].party_name

			if spell_recasts[spell_id] < spell_latency and not have_trust(party_name) then
				windower.chat.input('/ma "'..trust_name..'" <me>')
				add_tick_delay(1.5)
				return true
			end
		end
	end
	return false
end

function check_use_item()
	if useItem then
		local time_offset = local_offset - os.time()
		if useItemSlot == 'item' and (player.inventory[useItemName] or player.temporary[useItemName]) then
			windower.chat.input('/item "'..useItemName..'" <me>')
			add_tick_delay(2)
			return true
		elseif useItemSlot == 'set' then
			local set_to_item_name = set_to_item(useItemName)
			if item_equipped(set_to_item_name) then
				if get_usable_item(set_to_item_name).usable then
					windower.chat.input('/item "'..set_to_item_name..'" <me>')
					add_tick_delay(2)
					return true
				end
			elseif player.satchel[set_to_item_name] then
				send_command('get "'..set_to_item_name..'" '..consumable_bag)
				add_tick_delay(2)
				return true
			elseif item_available(set_to_item_name) and ((get_usable_item(set_to_item_name).next_use_time) + time_offset) < 10 then
				internal_disable_set(sets[useItemName], "UseItem")
				send_command('gs c update')
				add_tick_delay(2)
				return true
			else
				add_to_chat(123,''..set_to_item_name..' not available or ready for use.')
				useItem = false
				return false
			end
		elseif item_equipped(useItemName) then
			if get_usable_item(useItemName).usable then
				windower.chat.input('/item "'..useItemName..'" <me>')
				add_tick_delay(2)
				return true
			end
		elseif player.satchel[useItemName] then
			send_command('get "'..useItemName..'" '..consumable_bag)
			add_tick_delay(2)
			return true
		elseif item_available(useItemName) and ((get_usable_item(useItemName).next_use_time) + time_offset) < 10 then
			internal_disable_set({[useItemSlot]=useItemName}, "UseItem")
			send_command('gs c update')
			add_tick_delay(2)
			return true
		elseif item_stepdown[useItemName] then
			useItemSlot = item_stepdown[useItemName][2]
			useItemName = item_stepdown[useItemName][1]
			return false
		else
			add_to_chat(123,''..useItemName..' not available or ready for use.')
			useItem = false
			return false
		end
	else
		return false
	end
	return false
end

function check_lockstyle()
	if state.AutoLockstyle.value and style_lock and os.clock() > style_delay then
		if user_job_lockstyle then
			user_job_lockstyle()
		elseif user_lockstyle then
			user_lockstyle()
		else
			windower.chat.input('/lockstyle on')
		end
		style_lock = false
		style_delay = os.clock() + 15
	end
end

function check_food()
	if state.AutoFoodMode.value and not buffactive['Food'] and not data.areas.cities:contains(world.area) then

		if player.inventory[''..autofood..''] then
			windower.chat.input('/item "'..autofood..'" <me>')
			add_tick_delay(2)
			return true
		elseif player.satchel[''..autofood..''] then
			send_command('get "'..autofood..'" '..consumable_bag)
			add_tick_delay(2)
			return true
		else
			return false
		end

	else
		return false
	end
end

function check_doomed()
	if buffactive.doom and state.AutoRemoveDoomMode.value then

		if (buffactive.mute or buffactive.Omerta or buffactive.silence) or not (silent_can_cast("Cursna") and windower.ffxi.get_spell_recasts()[20] < spell_latency) then
			if state.AutoHolyWaterMode.value and not buffactive.muddle then
				if player.inventory['Hallowed Water'] then
					windower.chat.input('/item "Hallowed Water" <me>')
					add_to_chat(123,'You are doomed, using Hallowed Water.')
					add_tick_delay(1.25)
					return true
				elseif player.inventory['Holy Water'] or player.satchel['Holy Water'] then
					windower.chat.input('/item "Holy Water" <me>')
					add_to_chat(123,'You are doomed, using Holy Water.')
					add_tick_delay(1.25)
					return true
				elseif buffactive.silence then
						if player.inventory['Echo Drops'] or player.satchel['Echo Drops'] then
							windower.chat.input('/item "Echo Drops" <me>')
						elseif player.inventory["Remedy"] then
							windower.chat.input('/item "Remedy" <me>')
						end
						add_tick_delay(1.25)
						return true
				end
			end
		else
			windower.chat.input('/ma "Cursna" <me>')
			add_tick_delay()
			return true
		end
	else
		return false
	end
	return false
end

function check_delayed_cast()
	if delayed_cast ~= '' then
		send_command(''..delayed_cast..' '..delayed_target..'')
		add_tick_delay()
		delayed_cast = ''
		delayed_target = ''
		return true
	end
	return false
end

function check_ws()
	if state.AutoWSMode.value and not state.RngHelper.value and player.status == 'Engaged' and player.target and player.target.type == "MONSTER" and player.tp > 999 and not silent_check_amnesia() and not (player.target.distance > (19.7 + player.target.model_size)) then

	local available_ws = S(windower.ffxi.get_abilities().weapon_skills)

		if player.hpp < 41 and state.AutoWSRestore.value and available_ws:contains(47) and player.target.distance < (3.2 + player.target.model_size) then
			windower.chat.input('/ws "Sanguine Blade" <t>')
			add_tick_delay()
			return true
		elseif player.hpp < 41 and state.AutoWSRestore.value and available_ws:contains(105) and player.target.distance < (3.2 + player.target.model_size) then
			windower.chat.input('/ws "Catastrophe" <t>')
			add_tick_delay()
			return true
		elseif player.mpp < 31 and state.AutoWSRestore.value and available_ws:contains(109) and player.target.distance < (3.2 + player.target.model_size) then
			windower.chat.input('/ws "Entropy" <t>')
			add_tick_delay()
			return true
		elseif player.mpp < 31 and state.AutoWSRestore.value and available_ws:contains(171) and player.target.distance < (3.2 + player.target.model_size) then
			windower.chat.input('/ws "Mystic Boon" <t>')
			add_tick_delay()
			return true
		elseif player.target.distance > (3.2 + player.target.model_size) and not data.weaponskills.ranged:contains(autows) then
			return false
		elseif data.equipment.relic_weapons:contains(player.equipment.main) and state.MaintainAftermath.value and (not buffactive['Aftermath']) then
			windower.chat.input('/ws "'..data.weaponskills.relic[player.equipment.main]..'" <t>')
			add_tick_delay()
			return true
		elseif (buffactive['Aftermath: Lv.3'] or not state.MaintainAftermath.value or not data.equipment.mythic_weapons:contains(player.equipment.main)) and player.tp >= autowstp then
			windower.chat.input('/ws "'..autows..'" <t>')
			add_tick_delay()
			return true
		elseif player.tp == 3000 then
			windower.chat.input('/ws "'..data.weaponskills.mythic[player.equipment.main]..'" <t>')
			add_tick_delay()
			return true
		else
			return false
		end
	else
		return false
	end
end

function have_trust(trust_name)
	local party = windower.ffxi.get_party()

	for i = 1,5 do
		local member = party['p' .. i]
		if member then
			if member.name:lower() == trust_name:lower() then return true end
		end

	end

	return false
end

function is_party_member(player_id)
	local party = windower.ffxi.get_party()

	for i = 1,5 do
		local member = party['p' .. i]
		if member.mob.id then
			if member.mob.id == player_id then return true end
		end

	end

	return false
end

function get_usable_item(name)--returns time that you can use the item again
	for _,n in pairs({"inventory","wardrobe","wardrobe2","wardrobe3","wardrobe4","wardrobe5","wardrobe6","wardrobe7","wardrobe8","satchel"}) do
		for _,v in pairs(gearswap.items[n]) do
			if type(v) == "table" and v.id ~= 0 and res.items[v.id].english:lower() == name:lower() then
				return extdata.decode(v)
			end
		end
	end
end

function cp_ring_equip(ring)
	internal_disable_set({ring1=ring}, "UseItem")
end

function check_cpring()
	if player.main_job_level < 99 or buffactive["Emporox's Gift"] then
		local time_offset = local_offset - os.time()

		if data.equipment.xprings:contains(player.equipment.left_ring) and get_usable_item(player.equipment.left_ring).usable then
			windower.chat.input('/item "'..player.equipment.left_ring..'" <me>')
			cp_delay = 0
			return true
		end

		if item_available('Sprout Beret') then
			local sprout_beret = get_usable_item('Sprout Beret')
			if player.equipment.head and player.equipment.head == 'Sprout Beret' and sprout_beret.usable then
				windower.chat.input('/item "'..player.equipment.head..'" <me>')
				cp_delay = 0
				return true

			elseif ((sprout_beret.next_use_time + time_offset) < 6 and sprout_beret.charges_remaining > 0) then
				internal_disable_set({head="Sprout Beret"}, "UseItem")
				cp_delay = 10
				return true
			end
		end

		if item_available('Echad Ring') then
			local echad_ring = get_usable_item('Echad Ring')

			if ((echad_ring.next_use_time + time_offset) < 6 and echad_ring.charges_remaining > 0) then
				cp_ring_equip('Echad Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Caliber Ring') then
			local caliber_ring = get_usable_item('Caliber Ring')

			if ((caliber_ring.next_use_time + time_offset) < 6 and caliber_ring.charges_remaining > 0) then
				cp_ring_equip('Caliber Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Emperor Band') then
			local emperor_band = get_usable_item('Emperor Band')

			if ((emperor_band.next_use_time + time_offset) < 6 and emperor_band.charges_remaining > 0) then
				cp_ring_equip('Emperor Band')
				cp_delay = 10
				return true
			end
		end

		if item_available('Empress Band') then
			local empress_band = get_usable_item('Empress Band')

			if ((empress_band.next_use_time + time_offset) < 6 and empress_band.charges_remaining > 0) then
				cp_ring_equip('Empress Band')
				cp_delay = 10
				return true
			end
		end

		if item_available('Resolution Ring') then
			local resolution_ring = get_usable_item('Resolution Ring')

			if ((resolution_ring.next_use_time + time_offset) < 6 and resolution_ring.charges_remaining > 0) then
				cp_ring_equip('Resolution Ring')
				cp_delay = 10
				return true
			end
		end
	end

	if player.main_job_level == 99 then

		if player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent == 2100 and not buffactive["Emporox's Gift"] then
			if item_available("Emporox's Ring") then
				local emporox_ring = get_usable_item("Emporox's Ring")
				if player.equipment.left_ring and player.equipment.left_ring == "Emporox's Ring" and emporox_ring.usable then
					windower.chat.input('/item "Emporox\'s Ring" <me>')
					cp_delay = 0
					return true

				elseif ((emporox_ring.next_use_time + time_offset) < 6 and emporox_ring.charges_remaining > 0) then
					cp_ring_equip("Emporox's Ring")
					cp_delay = 10
					return true
				end
			end
		end

		if data.equipment.cprings:contains(player.equipment.left_ring) and get_usable_item(player.equipment.left_ring).usable then
			send_command('input /item "'..player.equipment.left_ring..'" <me>')
			cp_delay = 0
			return true
		end

		if item_available('Guide Beret') then
			local guide_beret = get_usable_item('Guide Beret')
			if player.equipment.head and player.equipment.head == 'Guide Beret' and guide_beret.usable then
				windower.chat.input('/item "'..player.equipment.head..'" <me>')
				cp_delay = 0
				return true

			elseif ((guide_beret.next_use_time + time_offset) < 6 and guide_beret.charges_remaining > 0) then
				internal_disable_set({head="Guide Beret"}, "UseItem")
				cp_delay = 10
				return true
			end
		end

		if item_available('Endorsement Ring') then
			local endorsement_ring = get_usable_item('Endorsement Ring')

			if ((endorsement_ring.next_use_time + time_offset) < 6 and endorsement_ring.charges_remaining > 0) then
				cp_ring_equip('Endorsement Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Trizek Ring') then
			local trizek_ring = get_usable_item('Trizek Ring')

			if ((trizek_ring.next_use_time + time_offset) < 6 and trizek_ring.charges_remaining > 0) then
				cp_ring_equip('Trizek Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Capacity Ring') then
			local capacity_ring = get_usable_item('Capacity Ring')

			if ((capacity_ring.next_use_time + time_offset) < 6 and capacity_ring.charges_remaining > 0) then
				cp_ring_equip('Capacity Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Vocation Ring') then
			local vocation_ring = get_usable_item('Vocation Ring')

			if ((vocation_ring.next_use_time + time_offset) < 6 and vocation_ring.charges_remaining > 0) then
				cp_ring_equip('Vocation Ring')
				cp_delay = 10
				return true
			end
		end

		if item_available('Facility Ring') then
			local facility_ring = get_usable_item('Facility Ring')

			if ((facility_ring.next_use_time + time_offset) < 6 and facility_ring.charges_remaining > 0) then
				cp_ring_equip('Facility Ring')
				cp_delay = 10
				return true
			end
		end
	end

	cp_delay = 0
	return false
end

function check_cpring_buff()-- returs true if you do not have the buff from xp cp ring
	cp_delay = cp_delay + 1

	if state.Capacity.value and cp_delay > 20 and not moving and not data.areas.cities:contains(world.area) then

		if player.satchel['Mecisto. Mantle'] then send_command('get "Mecisto. Mantle" satchel;wait 2;gs c update') end
		if player.satchel['Endorsement Ring'] then send_command('get "Endorsement Ring" satchel') end
		if player.satchel['Trizek Ring'] then send_command('get "Trizek Ring" satchel') end
		if player.satchel['Capacity Ring'] then send_command('get "Capacity Ring" satchel') end
		if player.satchel['Vocation Ring'] then send_command('get "Vocation Ring" satchel') end
		if player.satchel['Facility Ring'] then send_command('get "Facility Ring" satchel') end
		if player.satchel['Guide Beret'] then send_command('get "Guide Beret" satchel') end
		if player.main_job_level < 99 or buffactive["Emporox's Gift"] then
			if player.satchel['Echad Ring'] then send_command('get "Echad Ring" satchel') end
			if player.satchel['Caliber Ring'] then send_command('get "Caliber Ring" satchel') end
		elseif player.satchel["Emporox's Ring"] and player.main_job_level == 99 and player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent == 2100 then
			send_command('get "Emporox\'s Ring" satchel')
		end

		if buffactive['Commitment'] then
			return false
		elseif buffactive['Dedication'] == 2 then
			return false
		elseif not buffactive['Dedication'] then
			if check_cpring() then
				return true
			else
				return false
			end
		elseif buffactive['Dedication'] == 1 then
			if have_trust("Kupofried") then
				if check_cpring() then
					return true
				else
					return false
				end
			else
				return false
			end
		end
	else
		return false
	end
	return false
end

function is_defensive()
	if state.DefenseMode.value ~= 'None' or state.HybridMode.value:contains('DT') or state.HybridMode.value:contains('Tank') then
		return true
	else
		return false
	end
end

function has_shadows()
	if  buffactive["Copy Image (4+)"] then
		return 4
	elseif buffactive["Copy Image (3)"] then
		return 3
	elseif buffactive["Copy Image (2)"] then
		return 2
	elseif buffactive.Blink or buffactive["Copy Image"] then
		return 1
	else
		return 0
	end
end

function check_shadows()
	if not state.AutoShadowMode.value or moving or data.areas.cities:contains(world.area) then return false end
	local spell_recasts = windower.ffxi.get_spell_recasts()
	local currentshadows = has_shadows()
	if player.main_job == 'NIN' then
		if currentshadows < 3 and player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent > 99 and spell_recasts[340] < spell_latency then
			windower.chat.input('/ma "Utsusemi: San" <me>')
			add_tick_delay()
			return true
		elseif currentshadows < 2 then
			if spell_recasts[339] < spell_latency then
				windower.chat.input('/ma "Utsusemi: Ni" <me>')
				add_tick_delay()
				return true
			elseif spell_recasts[338] < spell_latency then
				windower.chat.input('/ma "Utsusemi: Ichi" <me>')
				add_tick_delay()
				return true
			else
				return false
			end
		else
			return false
		end
	elseif player.sub_job == 'NIN' then
		if currentshadows < 2 then
			if spell_recasts[339] < spell_latency then
				windower.chat.input('/ma "Utsusemi: Ni" <me>')
				add_tick_delay()
				return true
			elseif spell_recasts[338] < spell_latency then
				windower.chat.input('/ma "Utsusemi: Ichi" <me>')
				add_tick_delay()
				return true
			else
				return false
			end
		else
			return false
		end
	elseif currentshadows == 0 then
		if player.main_job == 'SAM' and windower.ffxi.get_ability_recasts()[133] < latency then
			windower.chat.input('/ja "Third Eye" <me>')
			add_tick_delay()
			return true
		elseif silent_can_cast("Occultation") and spell_recasts[679] < spell_latency then
			windower.chat.input('/ma "Occultation" <me>')
			add_tick_delay()
			return true
		elseif silent_can_cast("Blink") and spell_recasts[53] < spell_latency then
			windower.chat.input('/ma "Blink" <me>')
			add_tick_delay()
			return true
		elseif silent_can_cast("Zephyr Mantle") and spell_recasts[647] < spell_latency then
			windower.chat.input('/ma "Zephyr Mantle" <me>')
			add_tick_delay()
			return true
		elseif player.sub_job == 'SAM' and windower.ffxi.get_ability_recasts()[133] < latency then
			windower.chat.input('/ja "Third Eye" <me>')
			add_tick_delay()
			return true
		else
			return false
		end
	else
		return false
	end
end

function is_nuke(spell, spellMap)
	if (
		(spell.skill == 'Elemental Magic' and spellMap ~= 'ElementalEnfeeble' and spell.english ~= 'Impact') or
	    (player.main_job == 'BLU' and spell.skill == 'Blue Magic' and spellMap and spellMap:contains('Magical')) or
		(player.main_job == 'NIN' and spell.skill == 'Ninjutsu' and spellMap and spellMap:contains('ElementalNinjutsu')) or
		spell.english == 'Comet' or spell.english == 'Meteor' or spell.english == 'Death' or spell.english:startswith('Banish') or
		spell.english:startswith('Drain') or spell.english:startswith('Aspir') or spell.english:startswith('Holy') or spell.english == 'Kaustra'
		) then

		return true
	else
		return false
	end
end

function ammo_left()

	local InventoryAmmo = ((player.inventory[player.equipment.ammo] or {}).count or 0)
	local WardrobeAmmo = ((player.wardrobe[player.equipment.ammo] or {}).count or 0)
	local Wardrobe2Ammo = ((player.wardrobe2[player.equipment.ammo] or {}).count or 0)
	local Wardrobe3Ammo = ((player.wardrobe3[player.equipment.ammo] or {}).count or 0)
	local Wardrobe4Ammo = ((player.wardrobe4[player.equipment.ammo] or {}).count or 0)
	local Wardrobe5Ammo = ((player.wardrobe5[player.equipment.ammo] or {}).count or 0)
	local Wardrobe6Ammo = ((player.wardrobe6[player.equipment.ammo] or {}).count or 0)
	local Wardrobe7Ammo = ((player.wardrobe7[player.equipment.ammo] or {}).count or 0)
	local Wardrobe8Ammo = ((player.wardrobe8[player.equipment.ammo] or {}).count or 0)

	local AmmoLeft = InventoryAmmo + WardrobeAmmo + Wardrobe2Ammo + Wardrobe3Ammo + Wardrobe4Ammo + Wardrobe5Ammo + Wardrobe6Ammo + Wardrobe7Ammo + Wardrobe8Ammo

	return AmmoLeft
end

function add_tick_delay(seconds)
	if seconds == nil then seconds = 0 end
	local new_delay = os.clock() + seconds + .5 - latency
	if tickdelay < new_delay then tickdelay = new_delay end
end

function add_next_cast_delay(seconds)
	if seconds == nil then seconds = 0 end
	local new_delay = os.clock() + seconds
	next_cast = new_delay
	if tickdelay < next_cast then tickdelay = next_cast +.1 end
end

 --Equip command but accepts the set name as a string to work around inability to use equip() in raw events.
function do_equip(setname)
	send_command('gs equip '..setname..'')
end

function internal_disable_set(set, priority)
	disabled_sets[priority] = set

	build_internal_disable()
end

function build_internal_disable()
	internal_disable = {}

	for i, priority in ipairs(disable_priority) do
		internal_disable = set_combine(internal_disable, disabled_sets[priority])
	end
end

function internal_enable_set(priority)
	disabled_sets[priority] = nil

	build_internal_disable()
end

function seconds_to_clock(seconds)
  local seconds = tonumber(seconds)

  if seconds <= 0 then
	return "00:00:00";
  else
	hours = string.format("%01.f", math.floor(seconds/3600));
	mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)));
	secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60));
	return hours..":"..mins..":"..secs
  end
end

function parse_set_to_keys(str)
	if type(str) == 'table' then
		str = table.concat(str, ' ')
	end

	-- Parsing results get pushed into the result list.
	local result = L{}

	local remainder = str
	local key
	local stop
	local sep = '.'
	local count = 0

	-- Loop as long as remainder hasn't been nil'd or reduced to 0 characters, but only to a maximum of 30 tries.
	while remainder and #remainder and count < 30 do
		-- Try aaa.bbb set names first
		while sep == '.' do
			_,_,key,sep,remainder = remainder:find("^([^%.%[]*)(%.?%[?)(.*)")
			-- "key" is everything that is not . or [ 0 or more times.
			-- "sep" is the next divider, which is necessarily . or [
			-- "remainder" is everything after that
			result:append(key)
		end

		-- Then try aaa['bbb'] set names.
		-- Be sure to account for both single and double quote enclosures.
		-- Ignore periods contained within quote strings.
		while sep == '[' do
			_,_,sep,remainder = remainder:find([=[^(%'?%"?)(.*)]=]) --' --block bad text highlighting
			-- "sep" is the first ' or " found (or nil)
			-- remainder is everything after that (or nil)
			if sep == "'" then
				_,_,key,stop,sep,remainder = remainder:find("^([^']+)('])(%.?%[?)(.*)")
			elseif sep == '"' then
				_,_,key,stop,sep,remainder = remainder:find('^([^"]+)("])(%.?%[?)(.*)')
			elseif not sep or #sep == 0 then
				-- If there is no single or double quote detected, attempt to treat the index as a number or boolean
				local _,_,pot_key,pot_stop,pot_sep,pot_remainder = remainder:find('^([^%]]+)(])(%.?%[?)(.*)')
				if tonumber(pot_key) then
					key,stop,sep,remainder = tonumber(pot_key),pot_stop,pot_sep,pot_remainder
				elseif pot_key == 'true' then
					key,stop,sep,remainder = true,pot_stop,pot_sep,pot_remainder
				elseif pot_key == 'false' then
					key,stop,sep,remainder = false,pot_stop,pot_sep,pot_remainder
				end
			end
			result:append(key)
		end

		count = count +1
	end

	return result
end

function get_set_from_keys(keys)
	local set = keys[1] == 'sets' and _G or sets
	for key in (keys.it or it)(keys) do
		if key == nil then
			return nil
		end
		set = set[key]
		if not set then
			return nil
		end
	end

	return set
end

function face_target()
	local target = windower.ffxi.get_mob_by_index(windower.ffxi.get_player().target_index or 0)
	local self_vector = windower.ffxi.get_mob_by_index(windower.ffxi.get_player().index or 0)
	if target then  -- Please note if you target yourself you will face Due East
		local angle = (math.atan2((target.y - self_vector.y), (target.x - self_vector.x))*180/math.pi)*-1
		windower.ffxi.turn((angle):radian())
	else
		windower.add_to_chat(123,"Error: You're not targeting anything to face")
	end
end

function check_ammo()
	if state.AutoAmmoMode.value and player.equipment.range and not in_combat and not world.in_mog_house and not useItem then
		if type(ammostock) == 'table' then
			for ammo, ammo_count in pairs(ammostock) do
				if count_total_ammo(ammo) < ammo_count then
					if item_available(data.equipment.rema_ammo_pouch_of[ammo]) then
						if ((get_usable_item(data.equipment.rema_ammo_pouch_of[ammo]).next_use_time) + 18000 - os.time()) < 10 then
							add_to_chat(217, "You're low on " .. ammo .. ", using " .. data.equipment.rema_ammo_pouch_of[ammo] .. ".")
							useItem = true
							useItemName = data.equipment.rema_ammo_pouch_of[ammo]
							useItemSlot = 'waist'
							return true
						end
					elseif data.equipment.rema_ammo_weapon_of[ammo] == player.equipment.range and get_usable_item(player.equipment.range).usable then
						windower.chat.input("/item '".. player.equipment.range .."' <me>")
						add_to_chat(217,"You're low on ".. ammo ..", using ".. player.equipment.range ..".")
						add_tick_delay(2)
						return true
					end
				end
			end
		else
			if data.equipment.rema_ranged_weapons:contains(player.equipment.range) and count_total_ammo(data.equipment.rema_ranged_weapons_ammo[player.equipment.range]) < ammostock then
				if get_usable_item(player.equipment.range).usable then
					windower.chat.input("/item '"..player.equipment.range.."' <me>")
					add_to_chat(217,"You're low on "..data.equipment.rema_ranged_weapons_ammo[player.equipment.range]..", using "..player.equipment.range..".")
					add_tick_delay(2)
					return true
				elseif item_available(data.equipment.rema_ranged_weapons_ammo_pouch[player.equipment.range]) then
					if ((get_usable_item(data.equipment.rema_ranged_weapons_ammo_pouch[player.equipment.range]).next_use_time) + 18000 -os.time()) < 10 then
						add_to_chat(217,"You're low on "..data.equipment.rema_ranged_weapons_ammo[player.equipment.range]..", using "..data.equipment.rema_ranged_weapons_ammo_pouch[player.equipment.range]..".")
						useItem = true
						useItemName = data.equipment.rema_ranged_weapons_ammo_pouch[player.equipment.range]
						useItemSlot = 'waist'
						return true
					end
				end
			end
		end
	end
	return false
end

function count_available_ammo(ammo_name)
	local ammo_count = 0

	for _,n in pairs({"inventory","wardrobe","wardrobe2","wardrobe3","wardrobe4","wardrobe5","wardrobe6","wardrobe7","wardrobe8","satchel"}) do
		if player[n][ammo_name] then
			ammo_count = ammo_count + player[n][ammo_name].count
		end
	end

	return ammo_count
end

function count_total_ammo(ammo_name)
	local ammo_count = 0

	for _,n in pairs({"inventory","wardrobe","wardrobe2","wardrobe3","wardrobe4","wardrobe5","wardrobe6","wardrobe7","wardrobe8","satchel"}) do
		if player[n][ammo_name] then
			ammo_count = ammo_count + player[n][ammo_name].count
		end
	end

	return ammo_count
end

function check_rune()

	if state.AutoRuneMode.value and (player.main_job == 'RUN' or player.sub_job == 'RUN') then
		local abil_recasts = windower.ffxi.get_ability_recasts()

		if player.main_job == 'RUN' and (not buffactive[state.RuneElement.value] or buffactive[state.RuneElement.value] < 3) then
			if abil_recasts[92] > 0 then return false end
			windower.chat.input('/ja "'..state.RuneElement.value..'" <me>')
			add_tick_delay()
			return true

		elseif not buffactive[state.RuneElement.value] or buffactive[state.RuneElement.value] < 2 then
			if abil_recasts[92] > 0 then return false end
			windower.chat.input('/ja "'..state.RuneElement.value..'" <me>')
			add_tick_delay()
			return true

		elseif player.main_job == 'RUN' and abil_recasts[242] < latency and (player.hpp < 50 or (state.RuneElement.Value == 'Tenebrae' and player.mpp < 75)) then
			windower.chat.input('/ja "Vivacious Pulse" <me>')
			add_tick_delay()
			return true

		elseif not in_combat then
			return false

		elseif not buffactive['Pflug'] and abil_recasts[59] < latency then
			windower.chat.input('/ja "Pflug" <me>')
			add_tick_delay()
			return true

		elseif not (buffactive['Vallation'] or buffactive['Valiance']) then
			if abil_recasts[113] and abil_recasts[113] < latency then
				windower.chat.input('/ja "Valiance" <me>')
				add_tick_delay()
				return true
			elseif abil_recasts[23] < latency then
				windower.chat.input('/ja "Vallation" <me>')
				add_tick_delay()
				return true
			end
		end
	end

	return false
end

function check_ws_acc()
	if state.WeaponskillMode.value == 'Match' then
		return state.OffenseMode.value
	else
		return state.WeaponskillMode.value
	end
end

--Checks to see if you're 'Fencing', 'Dual Wielding', or 'Hand-to-Hand', or 'Two-Handed', or 'Unarmed'
function wielding(wield_check)
	local wield_type
	local main_id
	local sub_id

	--Guess I have to resort to player.equipment as a backup, can't think of anything better for being situation agnostic.
	if state.Weapons.value ~= 'None' and sets.weapons[state.Weapons.value] then
		main_id = get_item_id_by_name(sets.weapons[state.Weapons.value].main) or get_item_id_by_name(player.equipment.main) or nil
		sub_id = get_item_id_by_name(sets.weapons[state.Weapons.value].sub) or get_item_id_by_name(player.equipment.sub) or nil
	end

	main_id = main_id or get_item_id_by_name(player.equipment.main) or 'empty'
	sub_id = sub_id or get_item_id_by_name(player.equipment.sub) or 'empty'

	if main_id == 'empty' and sub_id ~= 'empty' then
		wield_type = 'Unarmed'
	elseif main_id ~= 'empty' and data.skills.two_handed_combat:contains(res.items[main_id].skill) then
		wield_type = 'Two-Handed'
	elseif (main_id == 'empty' and sub_id == 'empty') or (main_id ~= 'empty' and res.items[main_id].skill == 1) then
		wield_type = 'Hand-to-Hand'
	elseif (main_id ~= 'empty' and data.skills.one_handed_combat:contains(res.items[main_id].skill)) and (sub_id == 'empty' or res.items[sub_id].shield_size) then
		wield_type = 'Fencing'
	elseif sub_id ~= 'empty' and data.skills.one_handed_combat:contains(res.items[sub_id].skill) then
		wield_type = 'Dual Wielding'
	end

	if wield_check then
		return wield_check == wield_type
	else
		return wield_type
	end
end

-- Generic combat form handling
function update_combat_form()
	if sets.engaged[state.Weapons.value] then
		state.CombatForm:set(state.Weapons.value)
	elseif not player.equipment.main then
		if sets.engaged.Unarmed then
			state.CombatForm:set('Unarmed')
		else
			state.CombatForm:reset()
		end
	elseif sets.engaged.DW and state.Weapons.value:contains('DW') or state.Weapons.value:contains('Dual') or (state.Weapons.value == 'None' and can_dual_wield) then
		state.CombatForm:set('DW')
	elseif sets.engaged[player.equipment.main] then
		state.CombatForm:set(player.equipment.main)
	elseif sets.engaged.Fencer and wielding == 'Fencing' then
		state.CombatForm:set('Fencer')
	else
		state.CombatForm:reset()
	end
end

function get_item_id_by_name(name)
	if name == nil or name == 'empty' then return end

	return (player.inventory[name] or player.wardrobe[name] or player.wardrobe2[name] or player.wardrobe3[name] or player.wardrobe4[name] or player.wardrobe5[name] or player.wardrobe6[name] or player.wardrobe7[name] or player.wardrobe8[name] or {}).id
end

function get_item_table(item)
	if not item then return end

	local item_type = type(item)

	if item_type == 'string' then
		return res.items[get_item_id_by_name(item)]
	elseif item_type == 'table' then
		return res.items[get_item_id_by_name(item.name)]
	end
end

function is_rare(item)
	return get_item_table(item).flags:contains('Rare')
end

function set_to_item(set)
	for k, v in pairs(sets[set]) do
		if v ~= empty then
			return v
		end
	end
	return false
end

function item_equipped(item)
	item = item:lower()
	for k, v in pairs(player.equipment) do
		if v:lower() == item then
			return true
		end
	end
	return false
end

function get_current_stratagem_count()
	-- returns recast in seconds.
	local allRecasts = windower.ffxi.get_ability_recasts()
	local stratsRecast = allRecasts[231]
	local StratagemChargeTimer = 240
	local maxStratagems = 1

	if player.sub_job == 'SCH' then
		if player.sub_job_level > 49 then
			StratagemChargeTimer = 80
		elseif player.sub_job_level > 29 then
			StratagemChargeTimer = 120
		end
	elseif player.main_job_level > 89 then
		if player.job_points[(res.jobs[player.main_job_id].ens):lower()].jp_spent > 549 then
			StratagemChargeTimer = 33
		else
			StratagemChargeTimer = 48
		end
	elseif player.main_job_level > 69 then
		StratagemChargeTimer = 60
	elseif player.main_job_level > 49 then
		StratagemChargeTimer = 80
	elseif player.main_job_level > 29 then
		StratagemChargeTimer = 120
	end

	if player.sub_job == 'SCH' then
		if player.sub_job_level > 49 then
			maxStratagems = 3
		elseif player.sub_job_level > 29 then
			maxStratagems = 2
		end
	else
		maxStratagems = math.floor((player.main_job_level + 10) / 20)
	end

	return (math.floor(maxStratagems - (stratsRecast / StratagemChargeTimer)))
end

function arts_active()
	if state.Buff['Light Arts'] or state.Buff['Addendum: White'] then
		return 'White'
	elseif state.Buff['Dark Arts'] or state.Buff['Addendum: Black'] then
		return 'Black'
	else
		return false
	end
end

-- Movement Handling
lastlocation = {X=0,Y=0}
moving = false
wasmoving = false

windower.raw_register_event('outgoing chunk',function(id,data,modified,is_injected,is_blocked)
	if id == 0x015 then
		local currentlocation = {X=modified:sub(5,8), Y=modified:sub(13,16)}
		moving = currentlocation.X ~= lastlocation.X or currentlocation.Y ~= lastlocation.Y
		lastlocation = currentlocation

		if moving then
			if sets.Kiting and not wasmoving and not (player.status == 'Event' or midaction() or pet_midaction() or (os.clock() < (petWillAct + 2))) then
				send_command('gs c update')
			end
			if state.RngHelper.value and not buffactive['Hover Shot'] then
				send_command('gs rh clear')
			end
			if buffup~= '' then
				buffup = ''
				add_to_chat(123,'Buffup cancelled due to movement.')
			end

			if not state.Uninterruptible.value then delayed_cast = '' end
			prepared_action = ''
		elseif wasmoving then
			if not (player.status == 'Event' or (os.clock() < (next_cast + 1)) or pet_midaction() or (os.clock() < (petWillAct + 2))) then
				send_command('gs c update')
			end
		end

		wasmoving = moving

	end
end)

-- Uninterruptible Handling

state.Uninterruptible = M(false, 'Uninterruptible')
fixed_pos = ''

windower.raw_register_event('outgoing chunk',function(id,original,modified,injected,blocked)
	if not blocked and id == 0x15 and state.Uninterruptible.value then
		if player.status ~= 'Event' and (gearswap.cued_packet or just_acted()) and fixed_pos ~= '' then
			return original:sub(1,4)..fixed_pos..original:sub(17)
		else
			fixed_pos = original:sub(5,16)
		end
	end
end)

--TP Bonus Handling
Ikenga_vest_bonus = 190  -- It is 190 at R25. Don't edit here, the same variable is in place in both COR and RNG gearfiles.
Ikenga_axe_bonus = 300  -- It is 300 at R25. Don't edit here, add the variable to function user_job_setup() in WAR and BST gearfiles.

function get_effective_player_tp(spell, WSset)
	local effective_tp = player.tp

	if wielding() == 'Fencing' then effective_tp = effective_tp + get_fencer_tp_bonus(WSset) end
	if buffactive['Crystal Blessing'] then effective_tp = effective_tp + 250 end
	if data.equipment.magian_tp_bonus_melee_weapons:contains(player.equipment.main) then effective_tp = effective_tp + 1000 end
	if data.equipment.magian_tp_bonus_melee_weapons:contains(player.equipment.sub) then effective_tp = effective_tp + 1000 end
	if data.equipment.magian_tp_bonus_ranged_weapons:contains(player.equipment.range) then effective_tp = effective_tp + 1000 end
	if state.Buff['Warcry'] and player.main_job == "WAR" and lastwarcry == player.name then effective_tp = effective_tp + warcry_tp_bonus end
	if WSset.ear1 == "Moonshade Earring" or WSset.ear2 == "Moonshade Earring" then effective_tp = effective_tp + 250 end
	if WSset.head == "Mpaca's Cap" then effective_tp = effective_tp + 200 end
	if WSset.body == "Ikenga's Vest" then effective_tp = effective_tp + Ikenga_vest_bonus end
	if WSset.legs == "Boii Cuisses +3" then effective_tp = effective_tp + 100 end
	if player.equipment.main == "Ikenga's Axe" then effective_tp = effective_tp + Ikenga_axe_bonus end
	if player.equipment.sub == "Ikenga's Axe" then effective_tp = effective_tp + Ikenga_axe_bonus end

	if spell.skill == 'Marksmanship' or spell.skill == 'Archery' then
		if data.equipment.aeonic_weapons:contains(player.equipment.range) then effective_tp = effective_tp + 500 end
	else
		if data.equipment.aeonic_weapons:contains(player.equipment.main) then effective_tp = effective_tp + 500
		elseif player.equipment.main == 'Kunimune +1' then effective_tp = effective_tp + 500
		end
	end

	return effective_tp
end

function standardize_slot(slot)
	if type(slot) == 'table' then
		slot = slot.name
	end

	return slot
end

function standardize_set(set)
	local standardized_set = {}
	for slot, inner in pairs(set) do
		if data.slots.slot_names:contains(slot) then
			standardized_set[slot] = standardize_slot(inner)
		end
	end
	--We need to set '' instead of nil because we're going to be using string functions on these items.
	standardized_set.ear1 = standardized_set.ear1 or standardized_set.left_ear or standardized_set.lear or ''
	standardized_set.ear2 = standardized_set.ear2 or standardized_set.right_ear or standardized_set.rear or ''
	standardized_set.ring1 = standardized_set.ring1 or standardized_set.left_ring or standardized_set.lring or ''
	standardized_set.ring2 = standardized_set.ring2 or standardized_set.right_ring or standardized_set.rring or ''
	standardized_set.range = standardized_set.range or standardized_set.ranged or ''

	return standardized_set
end

do
	local fencer_tier_bonuses = {[0]=0,[1]=200,[2]=300,[3]=400,[4]=450,[5]=500,[6]=550,[7]=600}
	function get_fencer_tp_bonus(WSset)
		local fencer_tp_bonus = 0
		local adjusted_fencer_tier = base_fencer_tier

		if WSset.legs and WSset.legs:startswith('Boii Cuisses') then
			if WSset.legs:endswith('+3') then
				adjusted_fencer_tier = adjusted_fencer_tier + 3
			elseif WSset.legs:endswith('+2') then
					adjusted_fencer_tier = adjusted_fencer_tier + 3
			elseif WSset.legs:endswith('+1') then
				adjusted_fencer_tier = adjusted_fencer_tier + 2
			else
				adjusted_fencer_tier = adjusted_fencer_tier + 1
			end
		end
		if WSset.neck and (WSset.neck:contains('War. Beads') or WSset.neck:contains("Warrior's Beads")) then
			adjusted_fencer_tier = adjusted_fencer_tier + 1
		end
		if WSset.sub and WSset.sub == 'Blurred Shield +1' then
			adjusted_fencer_tier = adjusted_fencer_tier + 1
		end
		if WSset.hands and WSset.hands == 'Agoge Mufflers +3' then
			adjusted_fencer_tier = adjusted_fencer_tier + 1
		end

		if adjusted_fencer_tier > 7 then
			fencer_tp_bonus = 630
		else
			fencer_tp_bonus = fencer_tier_bonuses[adjusted_fencer_tier]
		end

		fencer_tp_bonus = fencer_tp_bonus + jp_fencer_tp_bonus
		return fencer_tp_bonus
	end
end

function get_fencer_gifts()
	local war_fencer_gift_tiers = {[80]=50,[405]=50,[980]=60,[1805]=70}
	local bst_fencer_gift_tiers = {[150]=50,[500]=50,[1125]=60,[2000]=70}
	local jp_spent_on_job = windower.ffxi.get_player().job_points[string.lower(player.main_job)].jp_spent
	local tp_bonus_from_jp = 0

	if player.main_job == "WAR" then
		for tier_threshold,tp_bonus in ipairs(war_fencer_gift_tiers) do
			if jp_spent_on_job >= tier_threshold then
				tp_bonus_from_jp = tp_bonus_from_jp + tp_bonus
			end
		end
	elseif player.main_job == "BST" then
		for tier_threshold,tp_bonus in ipairs(bst_fencer_gift_tiers) do
			if jp_spent_on_job >= tier_threshold then
				tp_bonus_from_jp = tp_bonus_from_jp + tp_bonus
			end
		end
	end

	return tp_bonus_from_jp
end

function get_base_fencer_tier()
	local fencer_jobs_level_thresholds = {['BRD'] = {85,95},['BST'] = {80,87,94},['WAR'] = {45,58,71,84,97}}
	local fencer_tier_level = 0

	if fencer_jobs_level_thresholds[player.main_job] ~= nil then
		for _,level_threshold in ipairs(fencer_jobs_level_thresholds[player.main_job]) do
			if player.main_job_level >= level_threshold then
				fencer_tier_level = fencer_tier_level + 1
			end
		end

	elseif fencer_jobs_level_thresholds[player.sub_job] ~= nil then
		for _,level_threshold in ipairs(fencer_jobs_level_thresholds[player.sub_job]) do
			if player.sub_job_level >= level_threshold then
				fencer_tier_level = fencer_tier_level + 1
			end
		end
	end

	return fencer_tier_level
end

base_fencer_tier = get_base_fencer_tier()
jp_fencer_tp_bonus = get_fencer_gifts()

function get_warcry_tp_bonus()
	local tp_bonus = 0

	if player.main_job == 'WAR' then
		local savagery_merits = windower.ffxi.get_player().merits.savagery and windower.ffxi.get_player().merits.savagery or 0
		tp_bonus = tp_bonus + (100 * savagery_merits)

		local relic_bonus_per_merit = 40
		if sets.precast.JA.Warcry and sets.precast.JA.Warcry.head and sets.precast.JA.Warcry.head:contains('Agoge Mask') then
			tp_bonus = tp_bonus + (relic_bonus_per_merit * savagery_merits)
		end
	end

	return tp_bonus
end

warcry_tp_bonus = get_warcry_tp_bonus()

function set_dual_wield()
	-- Checks Job Traits directly. Will always recognize DW appropriately for all jobs (NIN ,DNC, THF, BLU)
	local traits = T(windower.ffxi.get_abilities().job_traits)
	can_dual_wield = traits:any(function(v) return gearswap.res.job_traits[v].english == 'Dual Wield' end)

	send_command('gs c weapons initialize')
end

function get_closest_mob_id_by_name(name)
	local mob = get_closest_mob_by_name(name)
	return mob and mob.id or false
end

function get_closest_mob_by_name(name)
	local name = get_fuzzy_name(name)
	local mobs = windower.ffxi.get_mob_array()
	local best_match = nil

	for i, mob in pairs(mobs) do
		if mob.valid_target then
			local fuzzy_mob_name = get_fuzzy_name(mob.name)
			if (name:length() >= 3 and fuzzy_mob_name:contains(name)) or fuzzy_mob_name == name then
				local potential_match = mob
				potential_match.score = fuzzy_mob_name:length() - name:length()

				if not best_match or (best_match.distance > 20 and potential_match.distance <= 20) or (potential_match.score > best_match.score and potential_match.distance <= 20) or (potential_match.score == best_match.score and potential_match.distance < best_match.distance) then
					best_match = potential_match
				end
			end
		end
	end

	return best_match or false
end

function get_closest_party_member_by_name(name)
	local name = get_fuzzy_name(name)
	local best_match = nil

	for i, member in ipairs(party) do
		if member.valid_target then
			local fuzzy_member_name = get_fuzzy_name(party[i].name)
			if (name:length() >= 3 and fuzzy_member_name:contains(name)) or fuzzy_member_name == name then
				local potential_match = member
				potential_match.score = fuzzy_member_name:length() - name:length()

				if not best_match or (best_match.mob.distance > 20 and potential_match.mob.distance <= 20) or (potential_match.score > best_match.score and potential_match.mob.distance <= 20) or (potential_match.score == best_match.score and potential_match.mob.distance < best_match.mob.distance) then
					best_match = potential_match
				end
			end
		end
	end

	return best_match or false
end

function get_party_member_by_id(member_id)
	for i in ipairs(party) do
		if member_id == party[i].mob.id then
			return party[i]
		end
	end

	return false
end

function get_fuzzy_name(name)
	return name:lower():gsub("%s", ""):gsub("%p", "")
end